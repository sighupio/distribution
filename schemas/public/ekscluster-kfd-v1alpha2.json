{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A Fury Cluster deployed through AWS's Elastic Kubernetes Service",
  "type": "object",
  "properties": {
    "apiVersion": {
      "type": "string",
      "pattern": "^kfd\\.sighup\\.io/v\\d+((alpha|beta)\\d+)?$"
    },
    "kind": {
      "type": "string",
      "enum": ["EKSCluster"]
    },
    "metadata": {
      "$ref": "#/$defs/Metadata"
    },
    "spec": {
      "$ref": "#/$defs/Spec"
    }
  },
  "additionalProperties": false,
  "required": ["apiVersion", "kind", "metadata", "spec"],
  "$defs": {
    "Metadata": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "minLength": 1,
          "maxLength": 56
        }
      },
      "required": ["name"]
    },
    "Spec": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "distributionVersion": {
          "type": "string",
          "minLength": 1
        },
        "region": {
          "$ref": "#/$defs/Types.AwsRegion"
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "This map defines which will be the common tags that will be added to all the resources created on AWS."
        },
        "toolsConfiguration": {
          "$ref": "#/$defs/Spec.ToolsConfiguration"
        },
        "infrastructure": {
          "$ref": "#/$defs/Spec.Infrastructure"
        },
        "kubernetes": {
          "$ref": "#/$defs/Spec.Kubernetes"
        },
        "distribution": {
          "$ref": "#/$defs/Spec.Distribution"
        },
        "plugins": {
          "$ref": "../public/spec-plugins.json"
        }
      },
      "required": [
        "distributionVersion",
        "region",
        "kubernetes",
        "distribution",
        "toolsConfiguration"
      ],
      "if": {
        "anyOf": [
          {
            "properties": {
              "infrastructure": {
                "type": "null"
              }
            }
          },
          {
            "properties": {
              "infrastructure": {
                "properties": {
                  "vpc": {
                    "type": "null"
                  }
                }
              }
            }
          }
        ]
      },
      "then": {
        "properties": {
          "kubernetes": {
            "required": ["vpcId", "subnetIds"]
          }
        }
      },
      "else": {
        "properties": {
          "kubernetes": {
            "type": "object",
            "properties": {
              "vpcId": {
                "type": "null"
              },
              "subnetIds": {
                "type": "null"
              }
            }
          }
        }
      }
    },
    "Spec.ToolsConfiguration": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "terraform": {
          "$ref": "#/$defs/Spec.ToolsConfiguration.Terraform"
        }
      },
      "required": ["terraform"]
    },
    "Spec.ToolsConfiguration.Terraform": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "state": {
          "$ref": "#/$defs/Spec.ToolsConfiguration.Terraform.State"
        }
      },
      "required": ["state"]
    },
    "Spec.ToolsConfiguration.Terraform.State": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "s3": {
          "$ref": "#/$defs/Spec.ToolsConfiguration.Terraform.State.S3"
        }
      },
      "required": ["s3"]
    },
    "Spec.ToolsConfiguration.Terraform.State.S3": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "bucketName": {
          "$ref": "#/$defs/Types.AwsS3BucketName",
          "description": "This value defines which bucket will be used to store all the states"
        },
        "keyPrefix": {
          "$ref": "#/$defs/Types.AwsS3KeyPrefix",
          "description": "This value defines which folder will be used to store all the states inside the bucket"
        },
        "region": {
          "$ref": "#/$defs/Types.AwsRegion",
          "description": "This value defines in which region the bucket is located"
        },
        "skipRegionValidation": {
          "type": "boolean",
          "description": "This value defines if the region of the bucket should be validated or not by Terraform, useful when using a bucket in a recently added region"
        }
      },
      "required": ["bucketName", "keyPrefix", "region"]
    },
    "Spec.Infrastructure": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "vpc": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpc",
          "description": "This key defines the VPC that will be created in AWS"
        },
        "vpn": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpn",
          "description": "This section defines the creation of VPN bastions"
        }
      },
      "allOf": [
        {
          "if": {
            "allOf": [
              {
                "properties": {
                  "vpc": {
                    "type": "null"
                  }
                }
              },
              {
                "not": {
                  "properties": {
                    "vpn": {
                      "type": "null"
                    }
                  }
                }
              }
            ]
          },
          "then": {
            "properties": {
              "vpn": {
                "required": ["vpcId"]
              }
            }
          }
        },
        {
          "if": {
            "allOf": [
              {
                "not": {
                  "properties": {
                    "vpc": {
                      "type": "null"
                    }
                  }
                }
              },
              {
                "not": {
                  "properties": {
                    "vpn": {
                      "properties": {
                        "vpcId": {
                          "type": "null"
                        }
                      }
                    }
                  }
                }
              }
            ]
          },
          "then": {
            "properties": {
              "vpn": {
                "properties": {
                  "vpcId": {
                    "type": "null"
                  }
                }
              }
            }
          }
        }
      ]
    },
    "Spec.Infrastructure.Vpc": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "network": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpc.Network"
        }
      },
      "required": ["network"]
    },
    "Spec.Infrastructure.Vpc.Network": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "This is the CIDR of the VPC that will be created"
        },
        "subnetsCidrs": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpc.Network.SubnetsCidrs"
        }
      },
      "required": ["cidr", "subnetsCidrs"]
    },
    "Spec.Infrastructure.Vpc.Network.SubnetsCidrs": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "private": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "description": "These are the CIRDs for the private subnets, where the nodes, the pods, and the private load balancers will be created"
        },
        "public": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "description": "These are the CIDRs for the public subnets, where the public load balancers and the VPN servers will be created"
        }
      },
      "required": ["private", "public"]
    },
    "Spec.Infrastructure.Vpn": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "instances": {
          "type": "integer",
          "description": "The number of instances to create, 0 to skip the creation"
        },
        "port": {
          "$ref": "#/$defs/Types.TcpPort",
          "description": "The port used by the OpenVPN server"
        },
        "instanceType": {
          "type": "string",
          "description": "The size of the AWS EC2 instance"
        },
        "diskSize": {
          "type": "integer",
          "description": "The size of the disk in GB"
        },
        "operatorName": {
          "type": "string",
          "description": "The username of the account to create in the bastion's operating system"
        },
        "dhParamsBits": {
          "type": "integer",
          "description": "The dhParamsBits size used for the creation of the .pem file that will be used in the dh openvpn server.conf file"
        },
        "vpnClientsSubnetCidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "The CIDR that will be used to assign IP addresses to the VPN clients when connected"
        },
        "ssh": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpn.Ssh"
        },
        "vpcId": {
          "$ref": "#/$defs/Types.AwsVpcId",
          "description": "The VPC ID where the VPN servers will be created, required only if .spec.infrastructure.vpc is omitted"
        },
        "bucketNamePrefix": {
          "$ref": "#/$defs/Types.AwsS3BucketNamePrefix",
          "description": "This value defines the prefix that will be used to create the bucket name where the VPN servers will store the states"
        },
        "iamUserNameOverride": {
          "$ref": "#/$defs/Types.AwsIamRoleName",
          "description": "Overrides the default IAM user name for the VPN"
        }
      },
      "required": ["ssh", "vpnClientsSubnetCidr"]
    },
    "Spec.Infrastructure.Vpn.Ssh": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "publicKeys": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/Types.SshPubKey"
              },
              {
                "$ref": "#/$defs/Types.FileRef"
              }
            ]
          },
          "description": "This value defines the public keys that will be added to the bastion's operating system NOTES: Not yet implemented"
        },
        "githubUsersName": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1,
          "description": "The github user name list that will be used to get the ssh public key that will be added as authorized key to the operatorName user"
        },
        "allowedFromCidrs": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "description": "The CIDR enabled in the security group that can access the bastions in SSH"
        }
      },
      "required": ["allowedFromCidrs", "githubUsersName"]
    },
    "Spec.Kubernetes": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "vpcId": {
          "$ref": "#/$defs/Types.AwsVpcId",
          "description": "This value defines the VPC ID where the EKS cluster will be created, required only if .spec.infrastructure.vpc is omitted"
        },
        "clusterIAMRoleNamePrefixOverride": {
          "$ref": "#/$defs/Types.AwsIamRoleNamePrefix",
          "description": "Overrides the default IAM role name prefix for the EKS cluster"
        },
        "workersIAMRoleNamePrefixOverride": {
          "$ref": "#/$defs/Types.AwsIamRoleNamePrefix",
          "description": "Overrides the default IAM role name prefix for the EKS workers"
        },
        "subnetIds": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.AwsSubnetId"
          },
          "description": "This value defines the subnet IDs where the EKS cluster will be created, required only if .spec.infrastructure.vpc is omitted"
        },
        "apiServer": {
          "$ref": "#/$defs/Spec.Kubernetes.APIServer"
        },
        "serviceIpV4Cidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "This value defines the CIDR that will be used to assign IP addresses to the services"
        },
        "nodeAllowedSshPublicKey": {
          "anyOf": [
            {
              "$ref": "#/$defs/Types.AwsSshPubKey"
            },
            {
              "$ref": "#/$defs/Types.FileRef"
            }
          ],
          "description": "This key contains the ssh public key that can connect to the nodes via SSH using the ec2-user user"
        },
        "nodePoolsLaunchKind": {
          "type": "string",
          "enum": ["launch_configurations", "launch_templates", "both"],
          "description": "Either `launch_configurations`, `launch_templates` or `both`. For new clusters use `launch_templates`, for existing cluster you'll need to migrate from `launch_configurations` to `launch_templates` using `both` as interim."
        },
        "logRetentionDays": {
          "type": "integer",
          "description": "Optional Kubernetes Cluster log retention in days. Defaults to 90 days."
        },
        "logsTypes": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "api",
              "audit",
              "authenticator",
              "controllerManager",
              "scheduler"
            ]
          },
          "minItems": 0,
          "description": "Optional list of Kubernetes Cluster log types to enable. Defaults to all types."
        },
        "nodePools": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.NodePool"
          }
        },
        "awsAuth": {
          "$ref": "#/$defs/Spec.Kubernetes.AwsAuth"
        }
      },
      "required": [
        "apiServer",
        "nodeAllowedSshPublicKey",
        "nodePools",
        "nodePoolsLaunchKind"
      ]
    },
    "Spec.Kubernetes.APIServer": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "privateAccess": {
          "type": "boolean",
          "description": "This value defines if the API server will be accessible only from the private subnets"
        },
        "privateAccessCidrs": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "minItems": 0,
          "description": "This value defines the CIDRs that will be allowed to access the API server from the private subnets"
        },
        "publicAccessCidrs": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "minItems": 0,
          "description": "This value defines the CIDRs that will be allowed to access the API server from the public subnets"
        },
        "publicAccess": {
          "type": "boolean",
          "description": "This value defines if the API server will be accessible from the public subnets"
        }
      },
      "required": ["privateAccess", "publicAccess"]
    },
    "Spec.Kubernetes.NodePool": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": ["eks-managed", "self-managed"]
        },
        "name": {
          "type": "string",
          "description": "The name of the node pool"
        },
        "ami": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.Ami"
        },
        "containerRuntime": {
          "type": "string",
          "enum": ["docker", "containerd"],
          "description": "The container runtime to use for the nodes"
        },
        "size": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.Size"
        },
        "instance": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.Instance"
        },
        "attachedTargetGroups": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.AwsArn"
          },
          "description": "This optional array defines additional target groups to attach to the instances in the node pool"
        },
        "labels": {
          "$ref": "#/$defs/Types.KubeLabels",
          "description": "Kubernetes labels that will be added to the nodes"
        },
        "taints": {
          "$ref": "#/$defs/Types.KubeTaints",
          "description": "Kubernetes taints that will be added to the nodes"
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "AWS tags that will be added to the ASG and EC2 instances"
        },
        "subnetIds": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.AwsSubnetId"
          },
          "description": "This value defines the subnet IDs where the nodes will be created"
        },
        "additionalFirewallRules": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRules"
        }
      },
      "required": ["instance", "name", "size"]
    },
    "Spec.Kubernetes.NodePool.Ami": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "description": "The AMI ID to use for the nodes"
        },
        "owner": {
          "type": "string",
          "description": "The owner of the AMI"
        }
      },
      "required": ["id", "owner"]
    },
    "Spec.Kubernetes.NodePool.Instance": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "description": "The instance type to use for the nodes"
        },
        "spot": {
          "type": "boolean",
          "description": "If true, the nodes will be created as spot instances"
        },
        "volumeSize": {
          "type": "integer",
          "description": "The size of the disk in GB"
        },
        "volumeType": {
          "type": "string",
          "enum": ["gp2", "gp3", "io1", "standard"]
        },
        "maxPods": {
          "type": "integer"
        }
      },
      "required": ["type"]
    },
    "Spec.Kubernetes.NodePool.Size": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "min": {
          "type": "integer",
          "minimum": 0,
          "description": "The minimum number of nodes in the node pool"
        },
        "max": {
          "type": "integer",
          "minimum": 0,
          "description": "The maximum number of nodes in the node pool"
        }
      },
      "required": ["max", "min"]
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRules": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cidrBlocks": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.CidrBlock"
          },
          "minItems": 1,
          "description": "The CIDR blocks for the FW rule. At the moment the first item of the list will be used, others will be ignored."
        },
        "sourceSecurityGroupId": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.SourceSecurityGroupId"
          },
          "minItems": 1
        },
        "self": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.Self"
          },
          "minItems": 1
        }
      }
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRule.CidrBlock": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string"
        },
        "type": {
          "type": "string",
          "enum": ["ingress", "egress"]
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags"
        },
        "cidrBlocks": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "minItems": 1
        },
        "protocol": {
          "$ref": "#/$defs/Types.AwsIpProtocol"
        },
        "ports": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.Ports"
        }
      },
      "required": ["cidrBlocks", "name", "ports", "protocol", "type"]
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRule.SourceSecurityGroupId": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the FW rule"
        },
        "type": {
          "type": "string",
          "enum": ["ingress", "egress"],
          "description": "The type of the FW rule can be ingress or egress"
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "The tags of the FW rule"
        },
        "sourceSecurityGroupId": {
          "type": "string",
          "description": "The source security group ID"
        },
        "protocol": {
          "$ref": "#/$defs/Types.AwsIpProtocol",
          "description": "The protocol of the FW rule"
        },
        "ports": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.Ports"
        }
      },
      "required": ["sourceSecurityGroupId", "name", "ports", "protocol", "type"]
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRule.Self": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the FW rule"
        },
        "type": {
          "type": "string",
          "enum": ["ingress", "egress"],
          "description": "The type of the FW rule can be ingress or egress"
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "The tags of the FW rule"
        },
        "self": {
          "type": "boolean",
          "description": "If true, the source will be the security group itself"
        },
        "protocol": {
          "$ref": "#/$defs/Types.AwsIpProtocol",
          "description": "The protocol of the FW rule"
        },
        "ports": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.Ports"
        }
      },
      "required": ["self", "name", "ports", "protocol", "type"]
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRule.Ports": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "from": {
          "$ref": "#/$defs/Types.TcpPort"
        },
        "to": {
          "$ref": "#/$defs/Types.TcpPort"
        }
      },
      "required": ["from", "to"]
    },
    "Spec.Kubernetes.AwsAuth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "additionalAccounts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This optional array defines additional AWS accounts that will be added to the aws-auth configmap"
        },
        "users": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.AwsAuth.User"
          },
          "description": "This optional array defines additional IAM users that will be added to the aws-auth configmap"
        },
        "roles": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.AwsAuth.Role"
          },
          "description": "This optional array defines additional IAM roles that will be added to the aws-auth configmap"
        }
      }
    },
    "Spec.Kubernetes.AwsAuth.Role": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "username": {
          "type": "string"
        },
        "groups": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "rolearn": {
          "$ref": "#/$defs/Types.AwsArn"
        }
      },
      "required": ["groups", "rolearn", "username"]
    },
    "Spec.Kubernetes.AwsAuth.User": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "username": {
          "type": "string"
        },
        "groups": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "userarn": {
          "$ref": "#/$defs/Types.AwsArn"
        }
      },
      "required": ["groups", "userarn", "username"]
    },
    "Spec.Distribution": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "common": {
          "$ref": "#/$defs/Spec.Distribution.Common"
        },
        "modules": {
          "$ref": "#/$defs/Spec.Distribution.Modules"
        },
        "customPatches": {
          "$ref": "../public/spec-distribution-custom-patches.json"
        }
      },
      "required": ["modules"],
      "if": {
        "allOf": [
          {
            "required": ["common"]
          },
          {
            "properties": {
              "common": {
                "required": ["provider"]
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "required": ["type"]
                  }
                }
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "properties": {
                      "type": {
                        "const": "eks"
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      },
      "then": {
        "properties": {
          "modules": {
            "required": ["aws"]
          }
        }
      },
      "else": {
        "properties": {
          "modules": {
            "properties": {
              "aws": {
                "type": "null"
              }
            }
          }
        }
      }
    },
    "Spec.Distribution.Common": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for all the KFD modules"
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for all the KFD modules"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Common.Provider"
        },
        "relativeVendorPath": {
          "type": "string",
          "description": "The relative path to the vendor directory, does not need to be changed"
        }
      }
    },
    "Spec.Distribution.Common.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "description": "The type of the provider, must be EKS if specified"
        }
      },
      "required": ["type"]
    },
    "Spec.Distribution.Modules": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "auth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth"
        },
        "aws": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Aws"
        },
        "dr": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr"
        },
        "ingress": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress"
        },
        "logging": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging"
        },
        "monitoring": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring"
        },
        "tracing": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing"
        },
        "networking": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking"
        },
        "policy": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy"
        }
      },
      "required": ["dr", "ingress", "logging", "policy"]
    },
    "Spec.Distribution.Modules.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides"
        },
        "baseDomain": {
          "type": "string",
          "description": "the base domain used for all the KFD ingresses, if in the nginx dual configuration, it should be the same as the .spec.distribution.modules.ingress.dns.private.name zone"
        },
        "nginx": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx",
          "description": "Configurations for the nginx ingress controller module"
        },
        "certManager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager"
        },
        "dns": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.DNS"
        },
        "forecastle": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Forecastle"
        }
      },
      "required": ["baseDomain", "dns", "nginx"],
      "if": {
        "properties": {
          "nginx": {
            "properties": {
              "tls": {
                "properties": {
                  "provider": {
                    "const": "certManager"
                  }
                }
              }
            }
          }
        }
      },
      "then": {
        "required": ["certManager"]
      }
    },
    "Spec.Distribution.Modules.Ingress.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "ingresses": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides.Ingresses"
        },
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the ingress module"
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the ingress module"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Overrides.Ingresses": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "forecastle": {
          "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Forecastle": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": ["none", "single", "dual"],
          "description": "The type of the nginx ingress controller, must be ***none***, ***single*** or ***dual***"
        },
        "tls": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["type"]
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "provider": {
          "type": "string",
          "enum": ["certManager", "secret", "none"],
          "description": "The provider of the TLS certificate, must be ***none***, ***certManager*** or ***secret***"
        },
        "secret": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret"
        }
      },
      "required": ["provider"],
      "if": {
        "properties": {
          "provider": {
            "const": "secret"
          }
        }
      },
      "then": {
        "required": ["secret"]
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cert": {
          "type": "string",
          "description": "The certificate file content or you can use the file notation to get the content from a file"
        },
        "key": {
          "type": "string"
        },
        "ca": {
          "type": "string"
        }
      },
      "required": ["ca", "cert", "key"]
    },
    "Spec.Distribution.Modules.Ingress.CertManager": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "clusterIssuer": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["clusterIssuer"]
    },
    "Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the cluster issuer"
        },
        "email": {
          "type": "string",
          "format": "email",
          "description": "The email of the cluster issuer"
        },
        "type": {
          "type": "string",
          "enum": ["dns01", "http01"],
          "description": "The type of the cluster issuer, must be ***dns01*** or ***http01***"
        },
        "solvers": {
          "type": "array",
          "description": "The custom solvers configurations"
        }
      },
      "required": ["name", "email"],
      "oneOf": [
        {
          "required": ["type"]
        },
        {
          "required": ["solvers"]
        }
      ]
    },
    "Spec.Distribution.Modules.Ingress.DNS": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "public": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.DNS.Public"
        },
        "private": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.DNS.Private"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["public", "private"]
    },
    "Spec.Distribution.Modules.Ingress.DNS.Public": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the public hosted zone"
        },
        "create": {
          "type": "boolean",
          "description": "If true, the public hosted zone will be created"
        }
      },
      "required": ["name", "create"]
    },
    "Spec.Distribution.Modules.Ingress.DNS.Private": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the private hosted zone"
        },
        "create": {
          "type": "boolean",
          "description": "If true, the private hosted zone will be created"
        }
      },
      "required": ["name", "create"]
    },
    "Spec.Distribution.Modules.Logging": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": ["none", "opensearch", "loki"],
          "description": "The type of the logging, must be ***none***, ***opensearch*** or ***loki***"
        },
        "opensearch": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Opensearch"
        },
        "loki": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Loki"
        },
        "cerebro": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Cerebro"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Minio"
        },
        "operator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Operator"
        }
      },
      "required": ["type"],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "opensearch"
              }
            }
          },
          "then": {
            "required": ["opensearch"]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Logging.Opensearch": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": ["single", "triple"],
          "description": "The type of the opensearch, must be ***single*** or ***triple***"
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the opensearch pods"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["type"]
    },
    "Spec.Distribution.Modules.Logging.Cerebro": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Minio": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each minio disk, 6 disks total"
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username of the minio root user"
            },
            "password": {
              "type": "string",
              "description": "The password of the minio root user"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Loki": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "backend": {
          "type": "string",
          "enum": ["minio", "externalEndpoint"]
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint of the loki external endpoint"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the loki external endpoint will be insecure"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key of the loki external endpoint"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id of the loki external endpoint"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the loki external endpoint"
            }
          }
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Operator": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": ["none", "prometheus", "mimir"],
          "description": "The type of the monitoring, must be ***none***, ***prometheus*** or ***mimir***"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "prometheus": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Prometheus"
        },
        "alertmanager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.AlertManager"
        },
        "grafana": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Grafana"
        },
        "blackboxExporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.BlackboxExporter"
        },
        "kubeStateMetrics": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.KubeStateMetrics"
        },
        "x509Exporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.X509Exporter"
        },
        "mimir": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Mimir"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Minio"
        }
      },
      "required": ["type"]
    },
    "Spec.Distribution.Modules.Monitoring.Prometheus": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the prometheus pods"
        },
        "retentionSize": {
          "type": "string",
          "description": "The retention size for the prometheus pods"
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the prometheus pods"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.AlertManager": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "deadManSwitchWebhookUrl": {
          "type": "string",
          "description": "The webhook url to send deadman switch monitoring, for example to use with healthchecks.io"
        },
        "installDefaultRules": {
          "type": "boolean",
          "description": "If true, the default rules will be installed"
        },
        "slackWebhookUrl": {
          "type": "string",
          "description": "The slack webhook url to send alerts"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Grafana": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.BlackboxExporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.KubeStateMetrics": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.X509Exporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Mimir": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the mimir pods"
        },
        "backend": {
          "type": "string",
          "enum": ["minio", "externalEndpoint"],
          "description": "The backend for the mimir pods, must be ***minio*** or ***externalEndpoint***"
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint of the external mimir backend"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the external mimir backend will not use tls"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key of the external mimir backend"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id of the external mimir backend"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external mimir backend"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Minio": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The storage size for the minio pods"
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the minio root user"
            },
            "password": {
              "type": "string",
              "description": "The password for the minio root user"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": ["none", "tempo"],
          "description": "The type of tracing to use, either ***none*** or ***tempo***"
        },
        "tempo": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Tempo"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Minio"
        }
      },
      "required": ["type"]
    },
    "Spec.Distribution.Modules.Tracing.Tempo": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the tempo pods"
        },
        "backend": {
          "type": "string",
          "enum": ["minio", "externalEndpoint"],
          "description": "The backend for the tempo pods, must be ***minio*** or ***externalEndpoint***"
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint of the external tempo backend"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the external tempo backend will not use tls"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key of the external tempo backend"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id of the external tempo backend"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external tempo backend"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing.Minio": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The storage size for the minio pods"
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the minio root user"
            },
            "password": {
              "type": "string",
              "description": "The password for the minio root user"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Networking": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        },
        "tigeraOperator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking.TigeraOperator"
        }
      }
    },
    "Spec.Distribution.Modules.Networking.TigeraOperator": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Policy": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": ["none", "gatekeeper", "kyverno"],
          "description": "The type of security to use, either ***none***, ***gatekeeper*** or ***kyverno***"
        },
        "gatekeeper": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Gatekeeper"
        },
        "kyverno": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Kyverno"
        }
      },
      "required": ["type"],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": { "const": "gatekeeper" }
            }
          },
          "then": {
            "required": ["gatekeeper"]
          }
        },
        {
          "if": {
            "properties": {
              "type": { "const": "kyverno" }
            }
          },
          "then": {
            "required": ["kyverno"]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Policy.Gatekeeper": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Gatekeeper's exemption list, so it will not enforce the constraints on them."
        },
        "enforcementAction": {
          "type": "string",
          "enum": ["deny", "dryrun", "warn"],
          "description": "The enforcement action to use for the gatekeeper module"
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "If true, the default policies will be installed"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["enforcementAction", "installDefaultPolicies"]
    },
    "Spec.Distribution.Modules.Policy.Kyverno": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Kyverno's exemption list, so it will not enforce the constraints on them."
        },
        "validationFailureAction": {
          "type": "string",
          "enum": ["audit", "enforce"],
          "description": "The validation failure action to use for the kyverno module"
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "If true, the default policies will be installed"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["validationFailureAction", "installDefaultPolicies"]
    },
    "Spec.Distribution.Modules.Dr": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": ["none", "eks"],
          "description": "The type of the DR, must be ***none*** or ***eks***"
        },
        "velero": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr.Velero"
        }
      },
      "required": ["type"],
      "if": {
        "properties": {
          "type": {
            "const": "eks"
          }
        }
      },
      "then": {
        "required": ["type", "velero"]
      }
    },
    "Spec.Distribution.Modules.Dr.Velero": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "eks": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr.Velero.Eks"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["eks"]
    },
    "Spec.Distribution.Modules.Dr.Velero.Eks": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "region": {
          "$ref": "#/$defs/Types.AwsRegion",
          "description": "The region where the velero bucket is located"
        },
        "bucketName": {
          "$ref": "#/$defs/Types.AwsS3BucketName",
          "maxLength": 49,
          "description": "The name of the velero bucket"
        }
      },
      "required": ["region", "bucketName"]
    },
    "Spec.Distribution.Modules.Auth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider"
        },
        "baseDomain": {
          "type": "string",
          "description": "The base domain for the auth module"
        },
        "pomerium": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Pomerium"
        },
        "dex": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Dex"
        }
      },
      "required": ["provider"],
      "allOf": [
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "sso"
                  }
                }
              }
            }
          },
          "then": {
            "required": ["dex", "pomerium", "baseDomain"]
          },
          "else": {
            "properties": {
              "dex": {
                "type": "null"
              },
              "pomerium": {
                "type": "null"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "basicAuth"
                  }
                }
              }
            }
          },
          "then": {
            "properties": {
              "provider": {
                "required": ["basicAuth"]
              }
            }
          },
          "else": {
            "properties": {
              "provider": {
                "basicAuth": {
                  "type": "null"
                }
              }
            }
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Auth.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the auth module"
        },
        "tolerations": {
          "type": ["array", "null"],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the auth module"
        },
        "ingresses": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides.Ingress"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Auth.Overrides.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "host": {
          "type": "string",
          "description": "The host of the ingress"
        },
        "ingressClass": {
          "type": "string",
          "description": "The ingress class of the ingress"
        }
      },
      "required": ["host", "ingressClass"]
    },
    "Spec.Distribution.Modules.Auth.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": ["none", "basicAuth", "sso"],
          "description": "The type of the provider, must be ***none***, ***sso*** or ***basicAuth***"
        },
        "basicAuth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider.BasicAuth"
        }
      },
      "required": ["type"]
    },
    "Spec.Distribution.Modules.Auth.Provider.BasicAuth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "username": {
          "type": "string",
          "description": "The username for the basic auth"
        },
        "password": {
          "type": "string",
          "description": "The password for the basic auth"
        }
      },
      "required": ["username", "password"]
    },
    "Spec.Distribution.Modules.Auth.Pomerium": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "secrets": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Pomerium.Secrets"
        },
        "policy": {
          "type": "string",
          "description": "The policy for pomerium"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["secrets", "policy"]
    },
    "Spec.Distribution.Modules.Auth.Pomerium.Secrets": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "COOKIE_SECRET": {
          "type": "string",
          "description": "The cookie secret for pomerium"
        },
        "IDP_CLIENT_SECRET": {
          "type": "string",
          "description": "The IDP client secret for pomerium"
        },
        "SHARED_SECRET": {
          "type": "string",
          "description": "The shared secret for pomerium"
        }
      },
      "required": ["COOKIE_SECRET", "IDP_CLIENT_SECRET", "SHARED_SECRET"]
    },
    "Spec.Distribution.Modules.Auth.Dex": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "connectors": {
          "type": "array",
          "description": "The connectors for dex"
        },
        "additionalStaticClients": {
          "type": "array",
          "description": "The additional static clients for dex"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["connectors"]
    },
    "Spec.Distribution.Modules.Aws": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "clusterAutoscaler": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "overrides": {
              "$ref": "#/$defs/Types.FuryModuleComponentOverridesWithIAMRoleName"
            }
          }
        },
        "ebsCsiDriver": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "overrides": {
              "$ref": "#/$defs/Types.FuryModuleComponentOverridesWithIAMRoleName"
            }
          }
        },
        "loadBalancerController": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "overrides": {
              "$ref": "#/$defs/Types.FuryModuleComponentOverridesWithIAMRoleName"
            }
          }
        },
        "ebsSnapshotController": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "overrides": {
              "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        }
      }
    },

    "Types.SemVer": {
      "type": "string",
      "pattern": "^v?(?P<major>0|[1-9]\\d*)\\.(?P<minor>0|[1-9]\\d*)\\.(?P<patch>0|[1-9]\\d*)(?:-(?P<prerelease>(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
    },
    "Types.IpAddress": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\b){4}$"
    },
    "Types.Cidr": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}\\/(3[0-2]|[1-2][0-9]|[0-9])$"
    },
    "Types.FileRef": {
      "type": "string",
      "pattern": "^\\{file\\:\\/\\/.+\\}$"
    },
    "Types.EnvRef": {
      "type": "string",
      "pattern": "\\{^env\\:\\/\\/.*\\}$"
    },
    "Types.TcpPort": {
      "type": "integer",
      "minimum": 0,
      "maximum": 65535
    },
    "Types.SshPubKey": {
      "type": "string",
      "pattern": "^ssh\\-(dsa|ecdsa|ecdsa-sk|ed25519|ed25519-sk|rsa)\\s+"
    },
    "Types.Uri": {
      "type": "string",
      "pattern": "^(http|https)\\:\\/\\/.+$"
    },
    "Types.AwsArn": {
      "type": "string",
      "pattern": "^arn:(?P<Partition>[^:\\n]*):(?P<Service>[^:\\n]*):(?P<Region>[^:\\n]*):(?P<AccountID>[^:\\n]*):(?P<Ignore>(?P<ResourceType>[^:\\/\\n]*)[:\\/])?(?P<Resource>.*)$"
    },
    "Types.AwsRegion": {
      "type": "string",
      "enum": [
        "af-south-1",
        "ap-east-1",
        "ap-northeast-1",
        "ap-northeast-2",
        "ap-northeast-3",
        "ap-south-1",
        "ap-south-2",
        "ap-southeast-1",
        "ap-southeast-2",
        "ap-southeast-3",
        "ap-southeast-4",
        "ca-central-1",
        "eu-central-1",
        "eu-central-2",
        "eu-north-1",
        "eu-south-1",
        "eu-south-2",
        "eu-west-1",
        "eu-west-2",
        "eu-west-3",
        "me-central-1",
        "me-south-1",
        "sa-east-1",
        "us-east-1",
        "us-east-2",
        "us-gov-east-1",
        "us-gov-west-1",
        "us-west-1",
        "us-west-2"
      ]
    },
    "Types.AwsVpcId": {
      "type": "string",
      "pattern": "^vpc\\-([0-9a-f]{8}|[0-9a-f]{17})$"
    },
    "Types.AwsSshPubKey": {
      "type": "string",
      "pattern": "^ssh\\-(ed25519|rsa)\\s+"
    },
    "Types.AwsSubnetId": {
      "type": "string",
      "pattern": "^subnet\\-[0-9a-f]{17}$"
    },
    "Types.AwsTags": {
      "type": "object",
      "additionalProperties": { "type": "string" }
    },
    "Types.AwsIpProtocol": {
      "type": "string",
      "pattern": "^(?i)(tcp|udp|icmp|icmpv6|-1)$",
      "$comment": "this value should be lowercase, but we rely on terraform to do the conversion to make it a bit more user friendly"
    },
    "Types.AwsIamRoleNamePrefix": {
      "type": "string",
      "pattern": "^[a-zA-Z0-9+=,.@_-]{1,38}$"
    },
    "Types.AwsIamRoleName": {
      "type": "string",
      "pattern": "^[a-zA-Z0-9+=,.@_-]{1,63}$"
    },
    "Types.AwsS3BucketName": {
      "type": "string",
      "allOf": [
        {
          "pattern": "^[a-z0-9][a-z0-9-.]{1,61}[a-z0-9]$"
        },
        {
          "not": {
            "pattern": "^xn--|-s3alias$"
          }
        }
      ]
    },
    "Types.AwsS3BucketNamePrefix": {
      "type": "string",
      "allOf": [
        {
          "pattern": "^[a-z0-9][a-z0-9-.]{1,35}[a-z0-9-.]$"
        },
        {
          "not": {
            "pattern": "^xn--|-s3alias$"
          }
        }
      ]
    },
    "Types.AwsS3KeyPrefix": {
      "type": "string",
      "pattern": "^[A-z0-9][A-z0-9!-_.*'()]+$",
      "maxLength": 960
    },
    "Types.KubeLabels": {
      "type": "object",
      "additionalProperties": { "type": "string" }
    },
    "Types.KubeTaints": {
      "type": "array",
      "items": {
        "type": "string",
        "pattern": "^([a-zA-Z0-9\\-\\.\\/]+)=([^-][\\w-]+):(NoSchedule|PreferNoSchedule|NoExecute)$"
      }
    },
    "Types.KubeNodeSelector": {
      "type": ["object", "null"],
      "additionalProperties": { "type": "string" }
    },
    "Types.KubeToleration": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "effect": {
          "type": "string",
          "enum": ["NoSchedule", "PreferNoSchedule", "NoExecute"]
        },
        "operator": {
          "type": "string",
          "enum": ["Exists", "Equal"]
        },
        "key": {
          "type": "string",
          "description": "The key of the toleration"
        },
        "value": {
          "type": "string",
          "description": "The value of the toleration"
        }
      },
      "required": ["effect", "key"],
      "anyOf": [
        {
          "required": ["operator"]
        },
        {
          "required": ["value"]
        }
      ]
    },
    "Types.KubeResources": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "requests": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The cpu request for the prometheus pods"
            },
            "memory": {
              "type": "string",
              "description": "The memory request for the opensearch pods"
            }
          }
        },
        "limits": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The cpu limit for the opensearch pods"
            },
            "memory": {
              "type": "string",
              "description": "The memory limit for the opensearch pods"
            }
          }
        }
      }
    },
    "Types.FuryModuleOverrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the dr module"
        },
        "tolerations": {
          "type": ["array", "null"],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the monitoring module"
        },
        "ingresses": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
          }
        }
      }
    },
    "Types.FuryModuleComponentOverrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the minio module"
        },
        "tolerations": {
          "type": ["array", "null"],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the cert-manager module"
        }
      }
    },
    "Types.FuryModuleComponentOverridesWithIAMRoleName": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the load balancer controller module"
        },
        "tolerations": {
          "type": ["array", "null"],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the cluster autoscaler module"
        },
        "iamRoleName": {
          "$ref": "#/$defs/Types.AwsIamRoleName"
        }
      }
    },
    "Types.FuryModuleOverridesIngress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "disableAuth": {
          "type": "boolean",
          "description": "If true, the ingress will not have authentication"
        },
        "host": {
          "type": "string",
          "description": "The host of the ingress"
        },
        "ingressClass": {
          "type": "string",
          "description": "The ingress class of the ingress"
        }
      }
    }
  }
}
