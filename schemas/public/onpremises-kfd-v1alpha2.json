{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "",
  "type": "object",
  "properties": {
    "apiVersion": {
      "type": "string",
      "pattern": "^kfd\\.sighup\\.io/v\\d+((alpha|beta)\\d+)?$"
    },
    "kind": {
      "type": "string",
      "enum": [
        "OnPremises"
      ]
    },
    "metadata": {
      "$ref": "#/$defs/Metadata"
    },
    "spec": {
      "$ref": "#/$defs/Spec"
    }
  },
  "additionalProperties": false,
  "required": [
    "apiVersion",
    "kind",
    "metadata",
    "spec"
  ],
  "$defs": {
    "Metadata": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "minLength": 1,
          "maxLength": 56
        }
      },
      "required": [
        "name"
      ]
    },
    "Spec": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "distributionVersion": {
          "type": "string",
          "minLength": 1
        },
        "kubernetes": {
          "$ref": "#/$defs/Spec.Kubernetes"
        },
        "distribution": {
          "$ref": "#/$defs/Spec.Distribution"
        },
        "plugins": {
          "$ref": "./spec-plugins.json"
        }
      },
      "required": [
        "distributionVersion",
        "distribution"
      ]
    },
    "Spec.Kubernetes": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "pkiFolder": {
          "type": "string",
          "description": "The folder where the PKI will be stored"
        },
        "ssh": {
          "$ref": "#/$defs/Spec.Kubernetes.SSH"
        },
        "dnsZone": {
          "type": "string",
          "description": "The DNS zone to use for the cluster"
        },
        "controlPlaneAddress": {
          "type": "string",
          "description": "The address of the control plane"
        },
        "podCidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "The CIDR to use for the pods"
        },
        "svcCidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "The CIDR to use for the services"
        },
        "proxy": {
          "$ref": "#/$defs/Spec.Kubernetes.Proxy"
        },
        "loadBalancers": {
          "$ref": "#/$defs/Spec.Kubernetes.LoadBalancers"
        },
        "masters": {
          "$ref": "#/$defs/Spec.Kubernetes.Masters"
        },
        "nodes": {
          "$ref": "#/$defs/Spec.Kubernetes.Nodes"
        },
        "advanced": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced"
        },
        "advancedAnsible": {
          "$ref": "#/$defs/Spec.Kubernetes.AdvancedAnsible"
        }
      },
      "required": [
        "pkiFolder",
        "ssh",
        "dnsZone",
        "controlPlaneAddress",
        "podCidr",
        "svcCidr",
        "loadBalancers",
        "masters",
        "nodes"
      ]
    },
    "Spec.Kubernetes.SSH": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "username": {
          "type": "string",
          "description": "The username to use to connect to the nodes"
        },
        "keyPath": {
          "type": "string",
          "description": "The path to the private key to use to connect to the nodes"
        }
      },
      "required": [
        "username",
        "keyPath"
      ]
    },
    "Spec.Kubernetes.Proxy": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "http": {
          "$ref": "#/$defs/Types.Uri",
          "description": "The HTTP proxy to use"
        },
        "https": {
          "$ref": "#/$defs/Types.Uri",
          "description": "The HTTPS proxy to use"
        },
        "noProxy": {
          "type": "string",
          "description": "The no proxy to use"
        }
      },
      "required": []
    },
    "Spec.Kubernetes.LoadBalancers": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "If true, the load balancers will be enabled"
        },
        "hosts": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.LoadBalancers.Host"
          }
        },
        "keepalived": {
          "$ref": "#/$defs/Spec.Kubernetes.LoadBalancers.Keepalived"
        },
        "stats": {
          "$ref": "#/$defs/Spec.Kubernetes.LoadBalancers.Stats"
        },
        "additionalConfig": {
          "type": "string",
          "description": "The additional config to use"
        }
      },
      "required": [
        "enabled"
      ],
      "if": {
        "properties": {
          "enabled": {
            "const": true
          }
        }
      },
      "then": {
        "required": [
          "hosts",
          "keepalived",
          "stats"
        ]
      }
    },
    "Spec.Kubernetes.LoadBalancers.Host": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the host"
        },
        "ip": {
          "type": "string",
          "description": "The IP of the host"
        }
      },
      "required": [
        "name",
        "ip"
      ]
    },
    "Spec.Kubernetes.LoadBalancers.Keepalived": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "If true, keepalived will be enabled"
        },
        "interface": {
          "type": "string",
          "description": "The interface to use"
        },
        "ip": {
          "type": "string",
          "description": "The IP to use"
        },
        "virtualRouterId": {
          "type": "string",
          "description": "The virtual router ID to use"
        },
        "passphrase": {
          "type": "string",
          "description": "The passphrase to use"
        }
      },
      "required": [
        "enabled"
      ],
      "if": {
        "properties": {
          "enabled": {
            "const": true
          }
        }
      },
      "then": {
        "required": [
          "interface",
          "ip",
          "virtualRouterId",
          "passphrase"
        ]
      }
    },
    "Spec.Kubernetes.LoadBalancers.Stats": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "username": {
          "type": "string",
          "description": "The username to use"
        },
        "password": {
          "type": "string",
          "description": "The password to use"
        }
      },
      "required": [
        "username",
        "password"
      ]
    },
    "Spec.Kubernetes.Masters": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "hosts": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.Masters.Host"
          }
        }
      },
      "required": [
        "hosts"
      ]
    },
    "Spec.Kubernetes.Masters.Host": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the host"
        },
        "ip": {
          "type": "string",
          "description": "The IP of the host"
        }
      },
      "required": [
        "name",
        "ip"
      ]
    },
    "Spec.Kubernetes.Nodes": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#/$defs/Spec.Kubernetes.Nodes.Node"
      }
    },
    "Spec.Kubernetes.Nodes.Node": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string"
        },
        "hosts": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.Nodes.Node.Host"
          }
        },
        "taints": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeTaints"
          }
        }
      },
      "required": [
        "name",
        "hosts"
      ]
    },
    "Spec.Kubernetes.Nodes.Node.Host": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string"
        },
        "ip": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "ip"
      ]
    },
    "Spec.Kubernetes.AdvancedAnsible": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "pythonInterpreter": {
          "type": "string",
          "description": "The python interpreter to use"
        },
        "config": {
          "type": "string",
          "description": "Additional config to append to the ansible.cfg file"
        }
      }
    },
    "Spec.Kubernetes.Advanced": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cloud": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Cloud"
        },
        "users": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Users"
        },
        "oidc": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.OIDC"
        },
        "containerd": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Containerd"
        },
        "encryption": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Encryption"
        },
        "airGap": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.AirGap"
        },
        "registry": {
          "type": "string",
          "description": "URL of the registry where to pull images from for the Kubernetes phase. (Default is registry.sighup.io/fury/on-premises)."
        }
      }
    },
    "Spec.Kubernetes.Advanced.Cloud": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "provider": {
          "type": "string",
          "description": "The cloud provider to use"
        },
        "config": {
          "type": "string",
          "description": "The cloud config to use"
        }
      }
    },
    "Spec.Kubernetes.Advanced.Users": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "names": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The names of the users"
        },
        "org": {
          "type": "string",
          "description": "The org of the users"
        }
      }
    },
    "Spec.Kubernetes.Advanced.OIDC": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "issuer_url": {
          "type": "string",
          "description": "The issuer url of the oidc provider"
        },
        "client_id": {
          "type": "string",
          "description": "The client id of the oidc provider"
        },
        "ca_file": {
          "type": "string",
          "description": "The ca file of the oidc provider"
        },
        "username_claim": {
          "type": "string"
        },
        "username_prefix": {
          "type": "string"
        },
        "groups_claim": {
          "type": "string"
        },
        "group_prefix": {
          "type": "string"
        }
      }
    },
    "Spec.Kubernetes.Advanced.Containerd": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "registryConfigs": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Containerd.RegistryConfigs"
        }
      }
    },
    "Spec.Kubernetes.Advanced.Containerd.RegistryConfigs": {
      "description": "Allows specifying custom configuration for a registry at containerd level. You can set authentication details and mirrors for a registry.\nThis feature can be used for example to authenticate to a private registry at containerd (container runtime) level, i.e. globally instead of using `imagePullSecrets`. It also can be used to use a mirror for a registry or to enable insecure connections to trusted registries that don't support TLS.",
      "type": "array",
      "additionalProperties": false,
      "items": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "registry": {
            "type": "string"
          },
          "username": {
            "type": "string"
          },
          "password": {
            "type": "string"
          },
          "insecureSkipVerify": {
            "type": "boolean"
          },
          "mirrorEndpoint": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      }
    },
    "Spec.Kubernetes.Advanced.Encryption": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "tlsCipherSuites": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The tls cipher suites to use"
        },
        "configuration": {
          "type": "string",
          "description": "The configuration to use"
        }
      }
    },
    "Spec.Kubernetes.Advanced.AirGap": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "containerdDownloadUrl": {
          "type": "string",
          "description": "The containerd download url"
        },
        "runcDownloadUrl": {
          "type": "string",
          "description": "The runc download url"
        },
        "runcChecksum": {
          "type": "string",
          "description": "The runc checksum"
        },
        "etcdDownloadUrl": {
          "type": "string",
          "description": "The etcd download url"
        },
        "dependenciesOverride": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "apt": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "name": {
                  "type": "string",
                  "description": "The name of the apt dependency"
                },
                "repo": {
                  "type": "string",
                  "description": "The repo of the apt dependency"
                },
                "gpg_key": {
                  "type": "string",
                  "description": "The gpg key of the apt dependency"
                },
                "gpg_key_id": {
                  "type": "string",
                  "description": "The gpg key id of the apt dependency"
                }
              },
              "required": [
                "name",
                "repo",
                "gpg_key",
                "gpg_key_id"
              ]
            },
            "yum": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "name": {
                  "type": "string",
                  "description": "The name of the yum dependency"
                },
                "repo": {
                  "type": "string",
                  "description": "The repo of the yum dependency"
                },
                "gpg_key": {
                  "type": "string",
                  "description": "The gpg key of the yum dependency"
                },
                "gpg_key_check": {
                  "type": "boolean",
                  "description": "If true, the gpg key check will be enabled"
                },
                "repo_gpg_check": {
                  "type": "boolean",
                  "description": "If true, the repo gpg check will be enabled"
                }
              },
              "required": [
                "name",
                "repo",
                "gpg_key",
                "gpg_key_check",
                "repo_gpg_check"
              ]
            }
          }
        }
      }
    },
    "Spec.Distribution": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "common": {
          "$ref": "#/$defs/Spec.Distribution.Common"
        },
        "modules": {
          "$ref": "#/$defs/Spec.Distribution.Modules"
        },
        "customPatches": {
          "$ref": "../public/spec-distribution-custompatches.json"
        }
      },
      "required": [
        "modules"
      ],
      "if": {
        "allOf": [
          {
            "required": [
              "common"
            ]
          },
          {
            "properties": {
              "common": {
                "required": [
                  "provider"
                ]
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "required": [
                      "type"
                    ]
                  }
                }
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "properties": {
                      "type": {
                        "const": "eks"
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      }
    },
    "Spec.Distribution.Common": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for all the KFD modules"
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for all the KFD modules"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Common.Provider"
        },
        "relativeVendorPath": {
          "type": "string",
          "description": "The relative path to the vendor directory, does not need to be changed"
        },
        "registry": {
          "type": "string",
          "description": "URL of the registry where to pull images from for the Distribution phase. (Default is registry.sighup.io/fury)."
        }
      }
    },
    "Spec.Distribution.Common.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "description": "The type of the provider"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "auth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth"
        },
        "dr": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr"
        },
        "ingress": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress"
        },
        "logging": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging"
        },
        "monitoring": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring"
        },
        "tracing": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing"
        },
        "networking": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking"
        },
        "policy": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy"
        }
      },
      "required": [
        "dr",
        "ingress",
        "logging",
        "policy"
      ]
    },
    "Spec.Distribution.Modules.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides"
        },
        "baseDomain": {
          "type": "string",
          "description": "the base domain used for all the KFD ingresses, if in the nginx dual configuration, it should be the same as the .spec.distribution.modules.ingress.dns.private.name zone"
        },
        "nginx": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx",
          "description": "Configurations for the nginx ingress controller module"
        },
        "certManager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager"
        },
        "forecastle": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Forecastle"
        },
        "if": {
          "properties": {
            "nginx": {
              "properties": {
                "tls": {
                  "properties": {
                    "provider": {
                      "const": "certManager"
                    }
                  }
                }
              }
            }
          }
        },
        "then": {
          "required": [
            "certManager"
          ]
        }
      },
      "required": [
        "baseDomain",
        "nginx"
      ]
    },
    "Spec.Distribution.Modules.Ingress.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "ingresses": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides.Ingresses"
        },
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the ingress module"
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the ingress module"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Overrides.Ingresses": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "forecastle": {
          "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Forecastle": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "single",
            "dual"
          ],
          "description": "The type of the nginx ingress controller, must be ***none***, ***single*** or ***dual***"
        },
        "tls": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "provider": {
          "type": "string",
          "enum": [
            "certManager",
            "secret",
            "none"
          ],
          "description": "The provider of the TLS certificate, must be ***none***, ***certManager*** or ***secret***"
        },
        "secret": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret"
        }
      },
      "required": [
        "provider"
      ],
      "if": {
        "properties": {
          "provider": {
            "const": "secret"
          }
        }
      },
      "then": {
        "required": [
          "secret"
        ]
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cert": {
          "type": "string",
          "description": "The certificate file content or you can use the file notation to get the content from a file"
        },
        "key": {
          "type": "string"
        },
        "ca": {
          "type": "string"
        }
      },
      "required": [
        "ca",
        "cert",
        "key"
      ]
    },
    "Spec.Distribution.Modules.Ingress.CertManager": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "clusterIssuer": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "clusterIssuer"
      ]
    },
    "Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the cluster issuer"
        },
        "email": {
          "type": "string",
          "format": "email",
          "description": "The email of the cluster issuer"
        },
        "type": {
          "type": "string",
          "enum": [
            "http01"
          ],
          "description": "The type of the cluster issuer, must be ***http01***"
        },
        "solvers": {
          "type": "array",
          "description": "The custom solvers configurations"
        }
      },
      "required": [
        "name",
        "email"
      ],
      "oneOf": [
        {
          "required": [
            "type"
          ]
        },
        {
          "required": [
            "solvers"
          ]
        }
      ]
    },
    "Spec.Distribution.Modules.Logging": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "opensearch",
            "loki",
            "customOutputs"
          ],
          "description": "selects the logging stack. Choosing none will disable the centralized logging. Choosing opensearch will deploy and configure the Logging Operator and an OpenSearch cluster (can be single or triple for HA) where the logs will be stored. Choosing loki will use a distributed Grafana Loki instead of OpenSearh for storage. Choosing customOuput the Logging Operator will be deployed and installed but with no local storage, you will have to create the needed Outputs and ClusterOutputs to ship the logs to your desired storage."
        },
        "opensearch": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Opensearch"
        },
        "loki": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Loki"
        },
        "cerebro": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Cerebro"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Minio"
        },
        "operator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Operator"
        },
        "customOutputs": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.CustomOutputs"
        }
      },
      "required": [
        "type"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "opensearch"
              }
            }
          },
          "then": {
            "required": [
              "opensearch"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "customOutputs"
              }
            }
          },
          "then": {
            "required": [
              "customOutputs"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Logging.Opensearch": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "single",
            "triple"
          ],
          "description": "The type of the opensearch, must be ***single*** or ***triple***"
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the opensearch pods"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Logging.Cerebro": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Minio": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each minio disk, 6 disks total"
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username of the minio root user"
            },
            "password": {
              "type": "string",
              "description": "The password of the minio root user"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Loki": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ]
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint of the loki external endpoint"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the loki external endpoint will be insecure"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key of the loki external endpoint"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id of the loki external endpoint"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the loki external endpoint"
            }
          }
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Operator": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.CustomOutputs": {
      "description": "when using the customOutputs logging type, you need to manually specify the spec of the several Output and ClusterOutputs that the Logging Operator expects to forward the logs collected by the pre-defined flows.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "audit": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "events": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "infra": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "ingressNginx": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "kubernetes": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "systemdCommon": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "systemdEtcd": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "errors": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        }
      },
      "required": [
        "audit",
        "events",
        "infra",
        "ingressNginx",
        "kubernetes",
        "systemdCommon",
        "systemdEtcd",
        "errors"
      ]
    },
    "Spec.Distribution.Modules.Monitoring": {
      "type": "object",
      "additionalProperties": false,
      "description": "configuration for the Monitoring module components",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "prometheus",
            "prometheusAgent",
            "mimir"
          ],
          "description": "The type of the monitoring, must be ***none***, ***prometheus***, ***prometheusAgent*** or ***mimir***.\n\n- `none`: will disable the whole monitoring stack.\n- `prometheus`: will install Prometheus Operator and a preconfigured Prometheus instace, Alertmanager, a set of alert rules, exporters needed to monitor all the components of the cluster, Grafana and a series of dashboards to view the collected metrics, and more.\n- `prometheusAgent`: wil install Prometheus operator, an instance of Prometheus in Agent mode (no alerting, no queries, no storage), and all the exporters needed to get metrics for the status of the cluster and the workloads. Useful when having a centralized (remote) Prometheus where to ship the metrics and not storing them locally in the cluster.\n- `mimir`: will install the same as the `prometheus` option, and in addition Grafana Mimir that allows for longer retention of metrics and the usage of Object Storage."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "prometheus": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Prometheus"
        },
        "prometheusAgent": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.PrometheusAgent"
        },
        "alertmanager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.AlertManager"
        },
        "grafana": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Grafana"
        },
        "blackboxExporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.BlackboxExporter"
        },
        "kubeStateMetrics": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.KubeStateMetrics"
        },
        "x509Exporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.X509Exporter"
        },
        "mimir": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Mimir"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Minio"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Monitoring.Prometheus": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the k8s Prometheus instance."
        },
        "retentionSize": {
          "type": "string",
          "description": "The retention size for the k8s Prometheus instance."
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the k8s Prometheus instance."
        },
        "remoteWrite": {
          "description": "Set this option to ship the collected metrics to a remote Prometheus receiver.\n\n`remoteWrite` is an array of objects that allows configuring the [remoteWrite](https://prometheus.io/docs/specs/remote_write_spec/) options for Prometheus. The objects in the array follow [the same schema as in the prometheus operator](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.RemoteWriteSpec).",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.PrometheusAgent": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "remoteWrite": {
          "description": "Set this option to ship the collected metrics to a remote Prometheus receiver.\n\n`remoteWrite` is an array of objects that allows configuring the [remoteWrite](https://prometheus.io/docs/specs/remote_write_spec/) options for Prometheus. The objects in the array follow [the same schema as in the prometheus operator](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.RemoteWriteSpec).",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.AlertManager": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "deadManSwitchWebhookUrl": {
          "type": "string",
          "description": "The webhook url to send deadman switch monitoring, for example to use with healthchecks.io"
        },
        "installDefaultRules": {
          "type": "boolean",
          "description": "If true, the default rules will be installed"
        },
        "slackWebhookUrl": {
          "type": "string",
          "description": "The slack webhook url to send alerts"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Grafana": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "usersRoleAttributePath": {
          "type": "string",
          "description": "[JMESPath](http://jmespath.org/examples.html) expression to retrieve the user's role. Example:\n\n```yaml\nusersRoleAttributePath: \"contains(groups[*], 'beta') && 'Admin' || contains(groups[*], 'gamma') && 'Editor' || contains(groups[*], 'delta') && 'Viewer'\n```\n\nMore details in [Grafana's documentation](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/generic-oauth/#configure-role-mapping)."
        },
        "basicAuthIngress": {
          "type": "boolean",
          "description": "Setting this to true will deploy an additional `grafana-basic-auth` ingress protected with Grafana's basic auth instead of SSO. It's intended use is as a temporary ingress for when there are problems with the SSO login flow.\n\nNotice that by default anonymous access is enabled."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.BlackboxExporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.KubeStateMetrics": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.X509Exporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Mimir": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the mimir pods"
        },
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The backend for the mimir pods, must be ***minio*** or ***externalEndpoint***"
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint of the external mimir backend"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the external mimir backend will not use tls"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key of the external mimir backend"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id of the external mimir backend"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external mimir backend"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Minio": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The storage size for the minio pods"
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the minio root user"
            },
            "password": {
              "type": "string",
              "description": "The password for the minio root user"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "tempo"
          ],
          "description": "The type of tracing to use, either ***none*** or ***tempo***"
        },
        "tempo": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Tempo"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Minio"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Tracing.Tempo": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the tempo pods"
        },
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The backend for the tempo pods, must be ***minio*** or ***externalEndpoint***"
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint of the external tempo backend"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the external tempo backend will not use tls"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key of the external tempo backend"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id of the external tempo backend"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external tempo backend"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing.Minio": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The storage size for the minio pods"
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the minio root user"
            },
            "password": {
              "type": "string",
              "description": "The password for the minio root user"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Networking": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "tigeraOperator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking.TigeraOperator"
        },
        "cilium": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking.Cilium"
        },
        "type": {
          "type": "string",
          "enum": [
            "calico",
            "cilium"
          ],
          "description": "The type of networking to use, either ***calico*** or ***cilium***"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Networking.TigeraOperator": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Networking.Cilium": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "podCidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "The pod cidr to use for the cilium pods"
        },
        "maskSize": {
          "type": "string",
          "description": "The mask size to use for the cilium pods"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Policy": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "gatekeeper",
            "kyverno"
          ],
          "description": "The type of security to use, either ***none***, ***gatekeeper*** or ***kyverno***"
        },
        "gatekeeper": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Gatekeeper"
        },
        "kyverno": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Kyverno"
        }
      },
      "required": [
        "type"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "gatekeeper"
              }
            }
          },
          "then": {
            "required": [
              "gatekeeper"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "kyverno"
              }
            }
          },
          "then": {
            "required": [
              "kyverno"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Policy.Gatekeeper": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Gatekeeper's exemption list, so it will not enforce the constraints on them."
        },
        "enforcementAction": {
          "type": "string",
          "enum": [
            "deny",
            "dryrun",
            "warn"
          ],
          "description": "The enforcement action to use for the gatekeeper module"
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "If true, the default policies will be installed"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "enforcementAction",
        "installDefaultPolicies"
      ]
    },
    "Spec.Distribution.Modules.Policy.Kyverno": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Kyverno's exemption list, so it will not enforce the constraints on them."
        },
        "validationFailureAction": {
          "type": "string",
          "enum": [
            "audit",
            "enforce"
          ],
          "description": "The validation failure action to use for the kyverno module"
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "If true, the default policies will be installed"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "validationFailureAction",
        "installDefaultPolicies"
      ]
    },
    "Spec.Distribution.Modules.Dr": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "on-premises"
          ],
          "description": "The type of the DR, must be ***none*** or ***on-premises***"
        },
        "velero": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr.Velero"
        }
      },
      "required": [
        "type"
      ],
      "if": {
        "properties": {
          "type": {
            "const": "on-premises"
          }
        }
      },
      "then": {
        "required": [
          "type",
          "velero"
        ]
      }
    },
    "Spec.Distribution.Modules.Dr.Velero": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for velero"
        },
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The backend for velero"
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint for velero"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the endpoint will be insecure"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key for velero backend"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id for velero backend"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name for velero backend"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Auth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider"
        },
        "baseDomain": {
          "type": "string",
          "description": "The base domain for the auth module"
        },
        "pomerium": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Pomerium"
        },
        "dex": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Dex"
        },
        "oidcKubernetesAuth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.OIDCKubernetesAuth"
        }
      },
      "required": [
        "provider"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "sso"
                  }
                }
              }
            }
          },
          "then": {
            "required": [
              "dex",
              "pomerium",
              "baseDomain"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "basicAuth"
                  }
                }
              }
            }
          },
          "then": {
            "properties": {
              "provider": {
                "required": [
                  "basicAuth"
                ]
              }
            }
          }
        },
        {
          "allOf": [
            {
              "if": {
                "properties": {
                  "oidcKubernetesAuth": {
                    "type": "object"
                  }
                }
              }
            },
            {
              "if": {
                "properties": {
                  "oidcKubernetesAuth": {
                    "properties": {
                      "enabled": {
                        "const": true
                      }
                    }
                  }
                }
              }
            }
          ],
          "then": {
            "required": [
              "baseDomain",
              "dex"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Auth.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the auth module"
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the auth module"
        },
        "ingresses": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides.Ingress"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Auth.Overrides.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "host": {
          "type": "string",
          "description": "The host of the ingress"
        },
        "ingressClass": {
          "type": "string",
          "description": "The ingress class of the ingress"
        }
      },
      "required": [
        "host",
        "ingressClass"
      ]
    },
    "Spec.Distribution.Modules.Auth.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "basicAuth",
            "sso"
          ],
          "description": "The type of the provider, must be ***none***, ***sso*** or ***basicAuth***"
        },
        "basicAuth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider.BasicAuth"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Auth.Provider.BasicAuth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "username": {
          "type": "string",
          "description": "The username for the basic auth"
        },
        "password": {
          "type": "string",
          "description": "The password for the basic auth"
        }
      },
      "required": [
        "username",
        "password"
      ]
    },
    "Spec.Distribution.Modules.Auth.Pomerium": {
      "$ref": "./spec-distribution-modules-auth-pomerium.json"
    },
    "Spec.Distribution.Modules.Auth.Dex": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "connectors": {
          "type": "array",
          "description": "The connectors for dex"
        },
        "additionalStaticClients": {
          "type": "array",
          "description": "The additional static clients for dex"
        },
        "expiry": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "signingKeys": {
              "type": "string",
              "description": "Dex signing key expiration time duration (default 6h)."
            },
            "idTokens": {
              "type": "string",
              "description": "Dex ID tokens expiration time duration (default 24h)."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "connectors"
      ]
    },
    "Spec.Distribution.Modules.Auth.OIDCKubernetesAuth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "If true, oidc kubernetes auth will be enabled"
        },
        "clientID": {
          "type": "string",
          "description": "The client ID for oidc kubernetes auth"
        },
        "clientSecret": {
          "type": "string",
          "description": "The client secret for oidc kubernetes auth"
        },
        "scopes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The scopes for oidc kubernetes auth"
        },
        "usernameClaim": {
          "type": "string",
          "description": "The username claim for oidc kubernetes auth"
        },
        "emailClaim": {
          "type": "string",
          "description": "The email claim for oidc kubernetes auth"
        },
        "sessionSecurityKey": {
          "type": "string",
          "description": "The session security key for oidc kubernetes auth"
        },
        "removeCAFromKubeconfig": {
          "type": "boolean",
          "description": "Set to true to remove the CA from the kubeconfig file"
        },
        "namespace": {
          "type": "string",
          "description": "The namespace to set in the context of the kubeconfig file"
        }
      },
      "required": [
        "enabled"
      ],
      "if": {
        "properties": {
          "enabled": {
            "const": true
          }
        }
      },
      "then": {
        "required": [
          "clientID",
          "clientSecret",
          "sessionSecurityKey"
        ]
      }
    },
    "Types.SemVer": {
      "type": "string",
      "pattern": "^v?(?P<major>0|[1-9]\\d*)\\.(?P<minor>0|[1-9]\\d*)\\.(?P<patch>0|[1-9]\\d*)(?:-(?P<prerelease>(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
    },
    "Types.IpAddress": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\b){4}$"
    },
    "Types.Cidr": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}\\/(3[0-2]|[1-2][0-9]|[0-9])$"
    },
    "Types.FileRef": {
      "type": "string",
      "pattern": "^\\{file\\:\\/\\/.+\\}$"
    },
    "Types.EnvRef": {
      "type": "string",
      "pattern": "\\{^env\\:\\/\\/.*\\}$"
    },
    "Types.TcpPort": {
      "type": "integer",
      "minimum": 0,
      "maximum": 65535
    },
    "Types.SshPubKey": {
      "type": "string",
      "pattern": "^ssh\\-(dsa|ecdsa|ecdsa-sk|ed25519|ed25519-sk|rsa)\\s+"
    },
    "Types.Uri": {
      "type": "string",
      "pattern": "^(http|https)\\:\\/\\/.+$"
    },
    "Types.KubeLabels": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.KubeTaints": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "effect": {
          "type": "string",
          "enum": [
            "NoSchedule",
            "PreferNoSchedule",
            "NoExecute"
          ]
        },
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "required": [
        "effect",
        "key",
        "value"
      ]
    },
    "Types.KubeNodeSelector": {
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.KubeToleration": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "effect": {
          "type": "string",
          "enum": [
            "NoSchedule",
            "PreferNoSchedule",
            "NoExecute"
          ]
        },
        "operator": {
          "type": "string",
          "enum": [
            "Exists",
            "Equal"
          ]
        },
        "key": {
          "type": "string",
          "description": "The key of the toleration"
        },
        "value": {
          "type": "string",
          "description": "The value of the toleration"
        }
      },
      "required": [
        "effect",
        "key"
      ],
      "anyOf": [
        {
          "required": [
            "operator"
          ]
        },
        {
          "required": [
            "value"
          ]
        }
      ]
    },
    "Types.KubeResources": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "requests": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The cpu request for the loki pods"
            },
            "memory": {
              "type": "string",
              "description": "The memory request for the prometheus pods"
            }
          }
        },
        "limits": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The cpu limit for the loki pods"
            },
            "memory": {
              "type": "string",
              "description": "The memory limit for the prometheus pods"
            }
          }
        }
      }
    },
    "Types.FuryModuleOverrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the tracing module"
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the policy module"
        },
        "ingresses": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
          }
        }
      }
    },
    "Types.FuryModuleComponentOverrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the minio module"
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the minio module"
        }
      }
    },
    "Types.FuryModuleOverridesIngress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "disableAuth": {
          "type": "boolean",
          "description": "If true, the ingress will not have authentication"
        },
        "host": {
          "type": "string",
          "description": "The host of the ingress"
        },
        "ingressClass": {
          "type": "string",
          "description": "The ingress class of the ingress"
        }
      }
    }
  }
}