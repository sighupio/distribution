// Code generated by github.com/sighupio/go-jsonschema, DO NOT EDIT.

package public

import "encoding/json"
import "fmt"
import "reflect"

// A KFD Cluster deployed on bare metal infrastructure with iPXE boot provisioning
// and immutable OS configuration.
type ImmutableKfdV1Alpha2 struct {
	// ApiVersion corresponds to the JSON schema field "apiVersion".
	ApiVersion string `json:"apiVersion" yaml:"apiVersion" mapstructure:"apiVersion"`

	// Kind corresponds to the JSON schema field "kind".
	Kind ImmutableKfdV1Alpha2Kind `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// Spec corresponds to the JSON schema field "spec".
	Spec Spec `json:"spec" yaml:"spec" mapstructure:"spec"`
}

type ImmutableKfdV1Alpha2Kind string

const ImmutableKfdV1Alpha2KindImmutable ImmutableKfdV1Alpha2Kind = "Immutable"

type Metadata struct {
	// The name of the cluster. It will also be used as a prefix for all the other
	// resources created.
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type Spec struct {
	// Distribution corresponds to the JSON schema field "distribution".
	Distribution SpecDistribution `json:"distribution" yaml:"distribution" mapstructure:"distribution"`

	// Defines which KFD version will be installed and, in consequence, the Kubernetes
	// version used to create the cluster. It supports git tags and branches. Example:
	// `v1.32.1`.
	DistributionVersion string `json:"distributionVersion" yaml:"distributionVersion" mapstructure:"distributionVersion"`

	// Infrastructure corresponds to the JSON schema field "infrastructure".
	Infrastructure SpecInfrastructure `json:"infrastructure" yaml:"infrastructure" mapstructure:"infrastructure"`

	// Kubernetes corresponds to the JSON schema field "kubernetes".
	Kubernetes SpecKubernetes `json:"kubernetes" yaml:"kubernetes" mapstructure:"kubernetes"`

	// Plugins corresponds to the JSON schema field "plugins".
	Plugins *SpecPlugins `json:"plugins,omitempty" yaml:"plugins,omitempty" mapstructure:"plugins,omitempty"`
}

// Fury Kubernetes Distribution modules configuration. Ref:
// https://docs.kubernetesfury.com/
type SpecDistribution struct {
	// Common corresponds to the JSON schema field "common".
	Common *SpecDistributionCommon `json:"common,omitempty" yaml:"common,omitempty" mapstructure:"common,omitempty"`

	// CustomPatches corresponds to the JSON schema field "customPatches".
	CustomPatches *SpecDistributionCustompatches `json:"customPatches,omitempty" yaml:"customPatches,omitempty" mapstructure:"customPatches,omitempty"`

	// Modules corresponds to the JSON schema field "modules".
	Modules SpecDistributionModules `json:"modules" yaml:"modules" mapstructure:"modules"`
}

// Common configuration for all distribution modules.
type SpecDistributionCommon struct {
	// Node selector for all KFD module pods.
	NodeSelector TypesKubeNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// Container registry URL for KFD images. Example: registry.sighup.io/fury
	Registry *string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// Tolerations for all KFD module pods.
	Tolerations []TypesKubeToleration `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`
}

type SpecDistributionCustomPatchesConfigMapGenerator []SpecDistributionCustomPatchesConfigMapGeneratorResource

type SpecDistributionCustomPatchesConfigMapGeneratorResource struct {
	// The behavior of the configmap
	Behavior *SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior `json:"behavior,omitempty" yaml:"behavior,omitempty" mapstructure:"behavior,omitempty"`

	// The envs of the configmap
	Envs []string `json:"envs,omitempty" yaml:"envs,omitempty" mapstructure:"envs,omitempty"`

	// The files of the configmap
	Files []string `json:"files,omitempty" yaml:"files,omitempty" mapstructure:"files,omitempty"`

	// The literals of the configmap
	Literals []string `json:"literals,omitempty" yaml:"literals,omitempty" mapstructure:"literals,omitempty"`

	// The name of the configmap
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The namespace of the configmap
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Options corresponds to the JSON schema field "options".
	Options *SpecDistributionCustomPatchesConfigMapGeneratorResourceOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`
}

type SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior string

const SpecDistributionCustomPatchesConfigMapGeneratorResourceBehaviorCreate SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior = "create"
const SpecDistributionCustomPatchesConfigMapGeneratorResourceBehaviorMerge SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior = "merge"
const SpecDistributionCustomPatchesConfigMapGeneratorResourceBehaviorReplace SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior = "replace"

type SpecDistributionCustomPatchesConfigMapGeneratorResourceOptions struct {
	// The annotations of the configmap
	Annotations TypesKubeLabels `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// If true, the name suffix hash will be disabled
	DisableNameSuffixHash *bool `json:"disableNameSuffixHash,omitempty" yaml:"disableNameSuffixHash,omitempty" mapstructure:"disableNameSuffixHash,omitempty"`

	// If true, the configmap will be immutable
	Immutable *bool `json:"immutable,omitempty" yaml:"immutable,omitempty" mapstructure:"immutable,omitempty"`

	// The labels of the configmap
	Labels TypesKubeLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Each entry should follow the format of Kustomize's images patch
type SpecDistributionCustomPatchesImages []map[string]interface{}

type SpecDistributionCustomPatchesPatch struct {
	// Options corresponds to the JSON schema field "options".
	Options *SpecDistributionCustomPatchesPatchOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// The patch content
	Patch *string `json:"patch,omitempty" yaml:"patch,omitempty" mapstructure:"patch,omitempty"`

	// The path of the patch
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Target corresponds to the JSON schema field "target".
	Target *SpecDistributionCustomPatchesPatchTarget `json:"target,omitempty" yaml:"target,omitempty" mapstructure:"target,omitempty"`
}

type SpecDistributionCustomPatchesPatchOptions struct {
	// If true, the kind change will be allowed
	AllowKindChange *bool `json:"allowKindChange,omitempty" yaml:"allowKindChange,omitempty" mapstructure:"allowKindChange,omitempty"`

	// If true, the name change will be allowed
	AllowNameChange *bool `json:"allowNameChange,omitempty" yaml:"allowNameChange,omitempty" mapstructure:"allowNameChange,omitempty"`
}

type SpecDistributionCustomPatchesPatchTarget struct {
	// The annotation selector of the target
	AnnotationSelector *string `json:"annotationSelector,omitempty" yaml:"annotationSelector,omitempty" mapstructure:"annotationSelector,omitempty"`

	// The group of the target
	Group *string `json:"group,omitempty" yaml:"group,omitempty" mapstructure:"group,omitempty"`

	// The kind of the target
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// The label selector of the target
	LabelSelector *string `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// The name of the target
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The namespace of the target
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// The version of the target
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type SpecDistributionCustomPatchesPatches []SpecDistributionCustomPatchesPatch

// Each entry should be either a relative file path or an inline content resolving
// to a partial or complete resource definition
type SpecDistributionCustomPatchesPatchesStrategicMerge []string

type SpecDistributionCustomPatchesSecretGenerator []SpecDistributionCustomPatchesSecretGeneratorResource

type SpecDistributionCustomPatchesSecretGeneratorResource struct {
	// The behavior of the secret
	Behavior *SpecDistributionCustomPatchesSecretGeneratorResourceBehavior `json:"behavior,omitempty" yaml:"behavior,omitempty" mapstructure:"behavior,omitempty"`

	// The envs of the secret
	Envs []string `json:"envs,omitempty" yaml:"envs,omitempty" mapstructure:"envs,omitempty"`

	// The files of the secret
	Files []string `json:"files,omitempty" yaml:"files,omitempty" mapstructure:"files,omitempty"`

	// The literals of the secret
	Literals []string `json:"literals,omitempty" yaml:"literals,omitempty" mapstructure:"literals,omitempty"`

	// The name of the secret
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The namespace of the secret
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Options corresponds to the JSON schema field "options".
	Options *SpecDistributionCustomPatchesSecretGeneratorResourceOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// The type of the secret
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type SpecDistributionCustomPatchesSecretGeneratorResourceBehavior string

const SpecDistributionCustomPatchesSecretGeneratorResourceBehaviorCreate SpecDistributionCustomPatchesSecretGeneratorResourceBehavior = "create"
const SpecDistributionCustomPatchesSecretGeneratorResourceBehaviorMerge SpecDistributionCustomPatchesSecretGeneratorResourceBehavior = "merge"
const SpecDistributionCustomPatchesSecretGeneratorResourceBehaviorReplace SpecDistributionCustomPatchesSecretGeneratorResourceBehavior = "replace"

type SpecDistributionCustomPatchesSecretGeneratorResourceOptions struct {
	// The annotations of the secret
	Annotations TypesKubeLabels `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// If true, the name suffix hash will be disabled
	DisableNameSuffixHash *bool `json:"disableNameSuffixHash,omitempty" yaml:"disableNameSuffixHash,omitempty" mapstructure:"disableNameSuffixHash,omitempty"`

	// If true, the secret will be immutable
	Immutable *bool `json:"immutable,omitempty" yaml:"immutable,omitempty" mapstructure:"immutable,omitempty"`

	// The labels of the secret
	Labels TypesKubeLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

type SpecDistributionCustompatches struct {
	// ConfigMapGenerator corresponds to the JSON schema field "configMapGenerator".
	ConfigMapGenerator SpecDistributionCustomPatchesConfigMapGenerator `json:"configMapGenerator,omitempty" yaml:"configMapGenerator,omitempty" mapstructure:"configMapGenerator,omitempty"`

	// Images corresponds to the JSON schema field "images".
	Images SpecDistributionCustomPatchesImages `json:"images,omitempty" yaml:"images,omitempty" mapstructure:"images,omitempty"`

	// Patches corresponds to the JSON schema field "patches".
	Patches SpecDistributionCustomPatchesPatches `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// PatchesStrategicMerge corresponds to the JSON schema field
	// "patchesStrategicMerge".
	PatchesStrategicMerge SpecDistributionCustomPatchesPatchesStrategicMerge `json:"patchesStrategicMerge,omitempty" yaml:"patchesStrategicMerge,omitempty" mapstructure:"patchesStrategicMerge,omitempty"`

	// SecretGenerator corresponds to the JSON schema field "secretGenerator".
	SecretGenerator SpecDistributionCustomPatchesSecretGenerator `json:"secretGenerator,omitempty" yaml:"secretGenerator,omitempty" mapstructure:"secretGenerator,omitempty"`
}

// KFD modules configuration.
type SpecDistributionModules struct {
	// Authentication provider configuration.
	Auth SpecDistributionModulesAuth `json:"auth" yaml:"auth" mapstructure:"auth"`

	// Disaster recovery configuration. Ref: https://velero.io/docs/
	Dr SpecDistributionModulesDr `json:"dr" yaml:"dr" mapstructure:"dr"`

	// Ingress controller configuration. Ref:
	// https://kubernetes.github.io/ingress-nginx/
	Ingress SpecDistributionModulesIngress `json:"ingress" yaml:"ingress" mapstructure:"ingress"`

	// Logging stack configuration. Ref: https://grafana.com/docs/loki/latest/
	Logging SpecDistributionModulesLogging `json:"logging" yaml:"logging" mapstructure:"logging"`

	// Monitoring stack configuration. Ref:
	// https://prometheus.io/docs/introduction/overview/
	Monitoring SpecDistributionModulesMonitoring `json:"monitoring" yaml:"monitoring" mapstructure:"monitoring"`

	// CNI plugin configuration. Ref: https://docs.tigera.io/calico/latest/about/
	Networking SpecDistributionModulesNetworking `json:"networking" yaml:"networking" mapstructure:"networking"`

	// Policy engine configuration. Ref: https://kyverno.io/docs/
	Policy SpecDistributionModulesPolicy `json:"policy" yaml:"policy" mapstructure:"policy"`

	// Tracing configuration. Ref: https://grafana.com/docs/tempo/latest/
	Tracing *SpecDistributionModulesTracing `json:"tracing,omitempty" yaml:"tracing,omitempty" mapstructure:"tracing,omitempty"`
}

// Authentication provider configuration.
type SpecDistributionModulesAuth struct {
	// Provider corresponds to the JSON schema field "provider".
	Provider SpecDistributionModulesAuthProvider `json:"provider" yaml:"provider" mapstructure:"provider"`
}

type SpecDistributionModulesAuthProvider struct {
	// Authentication provider type.
	Type SpecDistributionModulesAuthProviderType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesAuthProviderType string

const SpecDistributionModulesAuthProviderTypeBasicAuth SpecDistributionModulesAuthProviderType = "basicAuth"
const SpecDistributionModulesAuthProviderTypeNone SpecDistributionModulesAuthProviderType = "none"
const SpecDistributionModulesAuthProviderTypeSso SpecDistributionModulesAuthProviderType = "sso"

// Disaster recovery configuration. Ref: https://velero.io/docs/
type SpecDistributionModulesDr struct {
	// DR backend type.
	Type SpecDistributionModulesDrType `json:"type" yaml:"type" mapstructure:"type"`

	// Velero corresponds to the JSON schema field "velero".
	Velero *SpecDistributionModulesDrVelero `json:"velero,omitempty" yaml:"velero,omitempty" mapstructure:"velero,omitempty"`
}

type SpecDistributionModulesDrType string

const SpecDistributionModulesDrTypeNone SpecDistributionModulesDrType = "none"
const SpecDistributionModulesDrTypeOnPremises SpecDistributionModulesDrType = "on-premises"

type SpecDistributionModulesDrVelero struct {
	// Backup storage backend.
	Backend *SpecDistributionModulesDrVeleroBackend `json:"backend,omitempty" yaml:"backend,omitempty" mapstructure:"backend,omitempty"`

	// S3 corresponds to the JSON schema field "s3".
	S3 *SpecDistributionModulesDrVeleroS3 `json:"s3,omitempty" yaml:"s3,omitempty" mapstructure:"s3,omitempty"`

	// Schedules corresponds to the JSON schema field "schedules".
	Schedules []SpecDistributionModulesDrVeleroSchedulesElem `json:"schedules,omitempty" yaml:"schedules,omitempty" mapstructure:"schedules,omitempty"`
}

type SpecDistributionModulesDrVeleroBackend string

const SpecDistributionModulesDrVeleroBackendMinio SpecDistributionModulesDrVeleroBackend = "minio"
const SpecDistributionModulesDrVeleroBackendS3 SpecDistributionModulesDrVeleroBackend = "s3"

type SpecDistributionModulesDrVeleroS3 struct {
	// S3 bucket name (3-63 chars, lowercase, no underscores). Example:
	// production-cluster-backups
	BucketName *string `json:"bucketName,omitempty" yaml:"bucketName,omitempty" mapstructure:"bucketName,omitempty"`

	// S3 endpoint URL.
	Endpoint *TypesUri `json:"endpoint,omitempty" yaml:"endpoint,omitempty" mapstructure:"endpoint,omitempty"`

	// S3 region.
	Region *string `json:"region,omitempty" yaml:"region,omitempty" mapstructure:"region,omitempty"`
}

type SpecDistributionModulesDrVeleroSchedulesElem struct {
	// Schedule name.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Cron expression (standard 5-field format). Examples: 0 3 * * *, */5 * * * *,
	// @daily
	Schedule string `json:"schedule" yaml:"schedule" mapstructure:"schedule"`

	// Backup retention duration. Example: 720h
	Ttl TypesDuration `json:"ttl" yaml:"ttl" mapstructure:"ttl"`
}

// Ingress controller configuration. Ref:
// https://kubernetes.github.io/ingress-nginx/
type SpecDistributionModulesIngress struct {
	// Base domain for ingresses (lowercase). Example: example.com
	BaseDomain string `json:"baseDomain" yaml:"baseDomain" mapstructure:"baseDomain"`

	// CertManager corresponds to the JSON schema field "certManager".
	CertManager *SpecDistributionModulesIngressCertManager `json:"certManager,omitempty" yaml:"certManager,omitempty" mapstructure:"certManager,omitempty"`

	// Nginx corresponds to the JSON schema field "nginx".
	Nginx SpecDistributionModulesIngressNginx `json:"nginx" yaml:"nginx" mapstructure:"nginx"`
}

type SpecDistributionModulesIngressCertManager struct {
	// ClusterIssuer corresponds to the JSON schema field "clusterIssuer".
	ClusterIssuer SpecDistributionModulesIngressCertManagerClusterIssuer `json:"clusterIssuer" yaml:"clusterIssuer" mapstructure:"clusterIssuer"`
}

type SpecDistributionModulesIngressCertManagerClusterIssuer struct {
	// Email for Let's Encrypt.
	Email string `json:"email" yaml:"email" mapstructure:"email"`

	// Cluster issuer name.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Challenge type.
	Type SpecDistributionModulesIngressCertManagerClusterIssuerType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesIngressCertManagerClusterIssuerType string

const SpecDistributionModulesIngressCertManagerClusterIssuerTypeHttp01 SpecDistributionModulesIngressCertManagerClusterIssuerType = "http01"

type SpecDistributionModulesIngressNginx struct {
	// Tls corresponds to the JSON schema field "tls".
	Tls *SpecDistributionModulesIngressNginxTls `json:"tls,omitempty" yaml:"tls,omitempty" mapstructure:"tls,omitempty"`

	// Nginx ingress controller type.
	Type SpecDistributionModulesIngressNginxType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesIngressNginxTls struct {
	// TLS certificate provider.
	Provider SpecDistributionModulesIngressNginxTlsProvider `json:"provider" yaml:"provider" mapstructure:"provider"`
}

type SpecDistributionModulesIngressNginxTlsProvider string

const SpecDistributionModulesIngressNginxTlsProviderCertManager SpecDistributionModulesIngressNginxTlsProvider = "certManager"
const SpecDistributionModulesIngressNginxTlsProviderNone SpecDistributionModulesIngressNginxTlsProvider = "none"
const SpecDistributionModulesIngressNginxTlsProviderSecret SpecDistributionModulesIngressNginxTlsProvider = "secret"

type SpecDistributionModulesIngressNginxType string

const SpecDistributionModulesIngressNginxTypeDual SpecDistributionModulesIngressNginxType = "dual"
const SpecDistributionModulesIngressNginxTypeNone SpecDistributionModulesIngressNginxType = "none"
const SpecDistributionModulesIngressNginxTypeSingle SpecDistributionModulesIngressNginxType = "single"

// Logging stack configuration. Ref: https://grafana.com/docs/loki/latest/
type SpecDistributionModulesLogging struct {
	// Loki corresponds to the JSON schema field "loki".
	Loki *SpecDistributionModulesLoggingLoki `json:"loki,omitempty" yaml:"loki,omitempty" mapstructure:"loki,omitempty"`

	// Minio corresponds to the JSON schema field "minio".
	Minio *SpecDistributionModulesLoggingMinio `json:"minio,omitempty" yaml:"minio,omitempty" mapstructure:"minio,omitempty"`

	// Logging backend type.
	Type SpecDistributionModulesLoggingType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesLoggingLoki struct {
	// Log retention period. Example: 720h
	RetentionPeriod *TypesDuration `json:"retentionPeriod,omitempty" yaml:"retentionPeriod,omitempty" mapstructure:"retentionPeriod,omitempty"`

	// Storage corresponds to the JSON schema field "storage".
	Storage *SpecDistributionModulesLoggingLokiStorage `json:"storage,omitempty" yaml:"storage,omitempty" mapstructure:"storage,omitempty"`
}

type SpecDistributionModulesLoggingLokiStorage struct {
	// Storage size. Example: 50Gi
	Size *TypesKubernetesQuantity `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`
}

type SpecDistributionModulesLoggingMinio struct {
	// MinIO storage size. Example: 20Gi
	StorageSize *TypesKubernetesQuantity `json:"storageSize,omitempty" yaml:"storageSize,omitempty" mapstructure:"storageSize,omitempty"`
}

type SpecDistributionModulesLoggingType string

const SpecDistributionModulesLoggingTypeLoki SpecDistributionModulesLoggingType = "loki"
const SpecDistributionModulesLoggingTypeNone SpecDistributionModulesLoggingType = "none"
const SpecDistributionModulesLoggingTypeOpensearch SpecDistributionModulesLoggingType = "opensearch"

// Monitoring stack configuration. Ref:
// https://prometheus.io/docs/introduction/overview/
type SpecDistributionModulesMonitoring struct {
	// Alertmanager corresponds to the JSON schema field "alertmanager".
	Alertmanager *SpecDistributionModulesMonitoringAlertmanager `json:"alertmanager,omitempty" yaml:"alertmanager,omitempty" mapstructure:"alertmanager,omitempty"`

	// Prometheus corresponds to the JSON schema field "prometheus".
	Prometheus *SpecDistributionModulesMonitoringPrometheus `json:"prometheus,omitempty" yaml:"prometheus,omitempty" mapstructure:"prometheus,omitempty"`

	// PrometheusAdapter corresponds to the JSON schema field "prometheusAdapter".
	PrometheusAdapter *SpecDistributionModulesMonitoringPrometheusAdapter `json:"prometheusAdapter,omitempty" yaml:"prometheusAdapter,omitempty" mapstructure:"prometheusAdapter,omitempty"`

	// Monitoring backend type.
	Type SpecDistributionModulesMonitoringType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesMonitoringAlertmanager struct {
	// DeadMansSwitch corresponds to the JSON schema field "deadMansSwitch".
	DeadMansSwitch *SpecDistributionModulesMonitoringAlertmanagerDeadMansSwitch `json:"deadMansSwitch,omitempty" yaml:"deadMansSwitch,omitempty" mapstructure:"deadMansSwitch,omitempty"`

	// Install default alerting rules.
	InstallDefaultRules *bool `json:"installDefaultRules,omitempty" yaml:"installDefaultRules,omitempty" mapstructure:"installDefaultRules,omitempty"`
}

type SpecDistributionModulesMonitoringAlertmanagerDeadMansSwitch struct {
	// Enable dead man's switch.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

type SpecDistributionModulesMonitoringPrometheus struct {
	// Metrics retention size. Example: 50GB
	RetentionSize *TypesKubernetesQuantity `json:"retentionSize,omitempty" yaml:"retentionSize,omitempty" mapstructure:"retentionSize,omitempty"`

	// Metrics retention time. Example: 15d
	RetentionTime *TypesDuration `json:"retentionTime,omitempty" yaml:"retentionTime,omitempty" mapstructure:"retentionTime,omitempty"`

	// Storage size for Prometheus. Example: 60Gi
	StorageSize *TypesKubernetesQuantity `json:"storageSize,omitempty" yaml:"storageSize,omitempty" mapstructure:"storageSize,omitempty"`
}

type SpecDistributionModulesMonitoringPrometheusAdapter struct {
	// Install enhanced HPA metrics.
	InstallEnhancedHPAMetrics *bool `json:"installEnhancedHPAMetrics,omitempty" yaml:"installEnhancedHPAMetrics,omitempty" mapstructure:"installEnhancedHPAMetrics,omitempty"`

	// Resources corresponds to the JSON schema field "resources".
	Resources *TypesKubeResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`
}

type SpecDistributionModulesMonitoringType string

const SpecDistributionModulesMonitoringTypeMimir SpecDistributionModulesMonitoringType = "mimir"
const SpecDistributionModulesMonitoringTypeNone SpecDistributionModulesMonitoringType = "none"
const SpecDistributionModulesMonitoringTypePrometheus SpecDistributionModulesMonitoringType = "prometheus"
const SpecDistributionModulesMonitoringTypePrometheusAgent SpecDistributionModulesMonitoringType = "prometheusAgent"

// CNI plugin configuration. Ref: https://docs.tigera.io/calico/latest/about/
type SpecDistributionModulesNetworking struct {
	// CNI plugin type.
	Type SpecDistributionModulesNetworkingType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesNetworkingType string

const SpecDistributionModulesNetworkingTypeCalico SpecDistributionModulesNetworkingType = "calico"
const SpecDistributionModulesNetworkingTypeCilium SpecDistributionModulesNetworkingType = "cilium"
const SpecDistributionModulesNetworkingTypeNone SpecDistributionModulesNetworkingType = "none"

// Policy engine configuration. Ref: https://kyverno.io/docs/
type SpecDistributionModulesPolicy struct {
	// Kyverno corresponds to the JSON schema field "kyverno".
	Kyverno *SpecDistributionModulesPolicyKyverno `json:"kyverno,omitempty" yaml:"kyverno,omitempty" mapstructure:"kyverno,omitempty"`

	// Policy engine type.
	Type SpecDistributionModulesPolicyType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesPolicyKyverno struct {
	// Install default Kyverno policies.
	InstallDefaultPolicies *bool `json:"installDefaultPolicies,omitempty" yaml:"installDefaultPolicies,omitempty" mapstructure:"installDefaultPolicies,omitempty"`

	// Default action for validation failures.
	ValidationFailureAction *SpecDistributionModulesPolicyKyvernoValidationFailureAction `json:"validationFailureAction,omitempty" yaml:"validationFailureAction,omitempty" mapstructure:"validationFailureAction,omitempty"`
}

type SpecDistributionModulesPolicyKyvernoValidationFailureAction string

const SpecDistributionModulesPolicyKyvernoValidationFailureActionAudit SpecDistributionModulesPolicyKyvernoValidationFailureAction = "Audit"
const SpecDistributionModulesPolicyKyvernoValidationFailureActionEnforce SpecDistributionModulesPolicyKyvernoValidationFailureAction = "Enforce"

type SpecDistributionModulesPolicyType string

const SpecDistributionModulesPolicyTypeGatekeeper SpecDistributionModulesPolicyType = "gatekeeper"
const SpecDistributionModulesPolicyTypeKyverno SpecDistributionModulesPolicyType = "kyverno"
const SpecDistributionModulesPolicyTypeNone SpecDistributionModulesPolicyType = "none"

// Tracing configuration. Ref: https://grafana.com/docs/tempo/latest/
type SpecDistributionModulesTracing struct {
	// Tempo corresponds to the JSON schema field "tempo".
	Tempo *SpecDistributionModulesTracingTempo `json:"tempo,omitempty" yaml:"tempo,omitempty" mapstructure:"tempo,omitempty"`

	// Tracing backend type.
	Type SpecDistributionModulesTracingType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesTracingTempo struct {
	// Trace retention time. Example: 720h
	RetentionTime *TypesDuration `json:"retentionTime,omitempty" yaml:"retentionTime,omitempty" mapstructure:"retentionTime,omitempty"`
}

type SpecDistributionModulesTracingType string

const SpecDistributionModulesTracingTypeNone SpecDistributionModulesTracingType = "none"
const SpecDistributionModulesTracingTypeTempo SpecDistributionModulesTracingType = "tempo"

// Defines the bare metal infrastructure configuration, including nodes, network
// boot, storage, and networking.
type SpecInfrastructure struct {
	// IpxeServer corresponds to the JSON schema field "ipxeServer".
	IpxeServer *SpecInfrastructureIpxeServer `json:"ipxeServer,omitempty" yaml:"ipxeServer,omitempty" mapstructure:"ipxeServer,omitempty"`

	// Global kernel parameters applied to all nodes at infrastructure level.
	// Node-specific parameters override these global values. Ref:
	// https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/
	KernelParameters []SpecInfrastructureKernelParameter `json:"kernelParameters,omitempty" yaml:"kernelParameters,omitempty" mapstructure:"kernelParameters,omitempty"`

	// List of bare metal nodes to provision.
	Nodes []SpecInfrastructureNode `json:"nodes" yaml:"nodes" mapstructure:"nodes"`

	// Proxy corresponds to the JSON schema field "proxy".
	Proxy *SpecInfrastructureProxy `json:"proxy,omitempty" yaml:"proxy,omitempty" mapstructure:"proxy,omitempty"`

	// Ssh corresponds to the JSON schema field "ssh".
	Ssh SpecInfrastructureSSH `json:"ssh" yaml:"ssh" mapstructure:"ssh"`
}

// iPXE server configuration for network boot provisioning. Ref:
// https://www.flatcar.org/docs/latest/setup/customization/
type SpecInfrastructureIpxeServer struct {
	// Advanced corresponds to the JSON schema field "advanced".
	Advanced *SpecInfrastructureIpxeServerAdvanced `json:"advanced,omitempty" yaml:"advanced,omitempty" mapstructure:"advanced,omitempty"`

	// The URL of the iPXE server (matchbox). Example:
	// https://ipxe.internal.example.com:8080
	Url TypesUri `json:"url" yaml:"url" mapstructure:"url"`
}

type SpecInfrastructureIpxeServerAdvanced struct {
	// Path to the matchbox assets directory. Example: /var/lib/matchbox/assets
	AssetsPath *string `json:"assetsPath,omitempty" yaml:"assetsPath,omitempty" mapstructure:"assetsPath,omitempty"`

	// Path to the matchbox data directory. Example: /var/lib/matchbox
	DataPath *string `json:"dataPath,omitempty" yaml:"dataPath,omitempty" mapstructure:"dataPath,omitempty"`

	// Log level for the iPXE server. Example: info
	LogLevel *SpecInfrastructureIpxeServerAdvancedLogLevel `json:"logLevel,omitempty" yaml:"logLevel,omitempty" mapstructure:"logLevel,omitempty"`
}

type SpecInfrastructureIpxeServerAdvancedLogLevel string

const SpecInfrastructureIpxeServerAdvancedLogLevelDebug SpecInfrastructureIpxeServerAdvancedLogLevel = "debug"
const SpecInfrastructureIpxeServerAdvancedLogLevelError SpecInfrastructureIpxeServerAdvancedLogLevel = "error"
const SpecInfrastructureIpxeServerAdvancedLogLevelInfo SpecInfrastructureIpxeServerAdvancedLogLevel = "info"
const SpecInfrastructureIpxeServerAdvancedLogLevelWarning SpecInfrastructureIpxeServerAdvancedLogLevel = "warning"

type SpecInfrastructureKernelParameter struct {
	// The kernel parameter name (sysctl format). Example: net.ipv4.ip_forward,
	// net.bridge.bridge-nf-call-iptables
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The kernel parameter value. Example: "1"
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// Definition of a bare metal node with storage, network, and hardware
// configuration.
type SpecInfrastructureNode struct {
	// CPU architecture for the node. Determines which sysext packages are downloaded.
	// Example: x86-64, arm64
	Arch SpecInfrastructureNodeArch `json:"arch,omitempty" yaml:"arch,omitempty" mapstructure:"arch,omitempty"`

	// Fully qualified domain name for the node. Example: node01.k8s.example.com
	Hostname string `json:"hostname" yaml:"hostname" mapstructure:"hostname"`

	// Iscsi corresponds to the JSON schema field "iscsi".
	Iscsi *SpecInfrastructureNodeIscsi `json:"iscsi,omitempty" yaml:"iscsi,omitempty" mapstructure:"iscsi,omitempty"`

	// Node-specific kernel parameters that override global settings.
	KernelParameters []SpecInfrastructureKernelParameter `json:"kernelParameters,omitempty" yaml:"kernelParameters,omitempty" mapstructure:"kernelParameters,omitempty"`

	// MAC address for PXE boot identification. Example: 52:54:00:10:00:01
	MacAddress TypesMacAddress `json:"macAddress" yaml:"macAddress" mapstructure:"macAddress"`

	// Multipath corresponds to the JSON schema field "multipath".
	Multipath *SpecInfrastructureNodeMultipath `json:"multipath,omitempty" yaml:"multipath,omitempty" mapstructure:"multipath,omitempty"`

	// Network corresponds to the JSON schema field "network".
	Network SpecInfrastructureNodeNetwork `json:"network" yaml:"network" mapstructure:"network"`

	// Storage corresponds to the JSON schema field "storage".
	Storage SpecInfrastructureNodeStorage `json:"storage" yaml:"storage" mapstructure:"storage"`
}

type SpecInfrastructureNodeArch string

const SpecInfrastructureNodeArchArm64 SpecInfrastructureNodeArch = "arm64"
const SpecInfrastructureNodeArchX8664 SpecInfrastructureNodeArch = "x86-64"

// iSCSI initiator configuration. Ref:
// https://www.flatcar.org/docs/latest/setup/customization/other-settings/
type SpecInfrastructureNodeIscsi struct {
	// iSCSI configuration content (required when enabled=true).
	Config *string `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Enable iSCSI support on this node.
	Enabled bool `json:"enabled" yaml:"enabled" mapstructure:"enabled"`
}

// DM-Multipath configuration for redundant storage paths.
type SpecInfrastructureNodeMultipath struct {
	// Multipath configuration content (required when enabled=true).
	Config *string `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Enable multipath support on this node.
	Enabled bool `json:"enabled" yaml:"enabled" mapstructure:"enabled"`
}

// Advanced network configuration with ethernets, bonds, and VLANs using networkd
// format.
type SpecInfrastructureNodeNetwork struct {
	// Bond interface configurations, keyed by bond name (e.g., bond0, bond1).
	Bonds SpecInfrastructureNodeNetworkBonds `json:"bonds,omitempty" yaml:"bonds,omitempty" mapstructure:"bonds,omitempty"`

	// Ethernet interface configurations, keyed by interface name (e.g., eth0, ens3,
	// eno49).
	Ethernets SpecInfrastructureNodeNetworkEthernets `json:"ethernets,omitempty" yaml:"ethernets,omitempty" mapstructure:"ethernets,omitempty"`
}

// Bond interface configuration for link aggregation.
type SpecInfrastructureNodeNetworkBond struct {
	// List of IP addresses in CIDR notation for the bond.
	Addresses []TypesCidr `json:"addresses,omitempty" yaml:"addresses,omitempty" mapstructure:"addresses,omitempty"`

	// Enable DHCPv4 on the bond. Default is false.
	Dhcp4 *bool `json:"dhcp4,omitempty" yaml:"dhcp4,omitempty" mapstructure:"dhcp4,omitempty"`

	// Default gateway IP address for the bond.
	Gateway *TypesIpAddress `json:"gateway,omitempty" yaml:"gateway,omitempty" mapstructure:"gateway,omitempty"`

	// List of member interfaces for the bond.
	Interfaces []string `json:"interfaces" yaml:"interfaces" mapstructure:"interfaces"`

	// Nameservers corresponds to the JSON schema field "nameservers".
	Nameservers *SpecInfrastructureNodeNetworkNameservers `json:"nameservers,omitempty" yaml:"nameservers,omitempty" mapstructure:"nameservers,omitempty"`

	// Parameters corresponds to the JSON schema field "parameters".
	Parameters SpecInfrastructureNodeNetworkBondParameters `json:"parameters" yaml:"parameters" mapstructure:"parameters"`

	// Static routes for this bond.
	Routes []SpecInfrastructureNodeNetworkRoute `json:"routes,omitempty" yaml:"routes,omitempty" mapstructure:"routes,omitempty"`
}

type SpecInfrastructureNodeNetworkBondParameters struct {
	// MII monitoring interval in milliseconds.
	MiiMonitorInterval *int `json:"miiMonitorInterval,omitempty" yaml:"miiMonitorInterval,omitempty" mapstructure:"miiMonitorInterval,omitempty"`

	// Minimum number of links that must be active before activating aggregate.
	MinLinks *int `json:"minLinks,omitempty" yaml:"minLinks,omitempty" mapstructure:"minLinks,omitempty"`

	// Bonding mode. Example: active-backup, 802.3ad
	Mode TypesBondMode `json:"mode" yaml:"mode" mapstructure:"mode"`
}

// Bond interface configurations, keyed by bond name (e.g., bond0, bond1).
type SpecInfrastructureNodeNetworkBonds map[string]SpecInfrastructureNodeNetworkBond

// Ethernet interface configuration.
type SpecInfrastructureNodeNetworkEthernet struct {
	// List of IP addresses in CIDR notation. Example: ["192.168.1.10/24"]
	Addresses []TypesCidr `json:"addresses,omitempty" yaml:"addresses,omitempty" mapstructure:"addresses,omitempty"`

	// Enable DHCPv4. Default is false.
	Dhcp4 *bool `json:"dhcp4,omitempty" yaml:"dhcp4,omitempty" mapstructure:"dhcp4,omitempty"`

	// Default gateway IP address.
	Gateway *TypesIpAddress `json:"gateway,omitempty" yaml:"gateway,omitempty" mapstructure:"gateway,omitempty"`

	// Nameservers corresponds to the JSON schema field "nameservers".
	Nameservers *SpecInfrastructureNodeNetworkNameservers `json:"nameservers,omitempty" yaml:"nameservers,omitempty" mapstructure:"nameservers,omitempty"`

	// Static routes for this interface.
	Routes []SpecInfrastructureNodeNetworkRoute `json:"routes,omitempty" yaml:"routes,omitempty" mapstructure:"routes,omitempty"`
}

// Ethernet interface configurations, keyed by interface name (e.g., eth0, ens3,
// eno49).
type SpecInfrastructureNodeNetworkEthernets map[string]SpecInfrastructureNodeNetworkEthernet

// DNS nameserver configuration.
type SpecInfrastructureNodeNetworkNameservers struct {
	// List of DNS server IP addresses.
	Addresses []TypesIpAddress `json:"addresses,omitempty" yaml:"addresses,omitempty" mapstructure:"addresses,omitempty"`

	// List of DNS search domains (supports single-level domains).
	Search []string `json:"search,omitempty" yaml:"search,omitempty" mapstructure:"search,omitempty"`
}

// Static route definition.
type SpecInfrastructureNodeNetworkRoute struct {
	// Destination network. Use 'default' for default route or specify CIDR. Examples:
	// default, 10.0.0.0/8
	To string `json:"to" yaml:"to" mapstructure:"to"`

	// Gateway IP address for this route.
	Via TypesIpAddress `json:"via" yaml:"via" mapstructure:"via"`
}

// Storage configuration for the node, including install disk and additional disks
// with partitions.
type SpecInfrastructureNodeStorage struct {
	// Additional disks to partition and mount.
	AdditionalDisks []SpecInfrastructureNodeStorageDisk `json:"additionalDisks,omitempty" yaml:"additionalDisks,omitempty" mapstructure:"additionalDisks,omitempty"`

	// The disk device where the OS will be installed. Example: /dev/sda
	InstallDisk TypesDevicePath `json:"installDisk" yaml:"installDisk" mapstructure:"installDisk"`
}

// Additional disk configuration with partitions.
type SpecInfrastructureNodeStorageDisk struct {
	// The disk device path. Example: /dev/sdb
	Device TypesDevicePath `json:"device" yaml:"device" mapstructure:"device"`

	// Partitions to create on this disk.
	Partitions []SpecInfrastructureNodeStoragePartition `json:"partitions" yaml:"partitions" mapstructure:"partitions"`
}

// Filesystem configuration for a partition.
type SpecInfrastructureNodeStorageFilesystem struct {
	// Filesystem type. Example: ext4, xfs
	Format TypesFilesystemType `json:"format" yaml:"format" mapstructure:"format"`

	// Filesystem label (max 12 chars for XFS compatibility). Example: ETCD
	Label string `json:"label" yaml:"label" mapstructure:"label"`

	// Mount options (validated safe options only). Example: ["noatime", "nodiratime"]
	MountOptions []SpecInfrastructureNodeStorageFilesystemMountOptionsElem `json:"mountOptions,omitempty" yaml:"mountOptions,omitempty" mapstructure:"mountOptions,omitempty"`

	// Mount point path. Example: /var/lib/etcd
	MountPoint string `json:"mountPoint" yaml:"mountPoint" mapstructure:"mountPoint"`
}

type SpecInfrastructureNodeStorageFilesystemMountOptionsElem string

const SpecInfrastructureNodeStorageFilesystemMountOptionsElemAsync SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "async"
const SpecInfrastructureNodeStorageFilesystemMountOptionsElemDefaults SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "defaults"
const SpecInfrastructureNodeStorageFilesystemMountOptionsElemDiscard SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "discard"
const SpecInfrastructureNodeStorageFilesystemMountOptionsElemNoatime SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "noatime"
const SpecInfrastructureNodeStorageFilesystemMountOptionsElemNodev SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "nodev"
const SpecInfrastructureNodeStorageFilesystemMountOptionsElemNodiratime SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "nodiratime"
const SpecInfrastructureNodeStorageFilesystemMountOptionsElemNodiscard SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "nodiscard"
const SpecInfrastructureNodeStorageFilesystemMountOptionsElemNoexec SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "noexec"
const SpecInfrastructureNodeStorageFilesystemMountOptionsElemNosuid SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "nosuid"
const SpecInfrastructureNodeStorageFilesystemMountOptionsElemRelatime SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "relatime"
const SpecInfrastructureNodeStorageFilesystemMountOptionsElemRo SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "ro"
const SpecInfrastructureNodeStorageFilesystemMountOptionsElemRw SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "rw"

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionCustomPatchesSecretGeneratorResourceBehavior) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionCustomPatchesSecretGeneratorResourceBehavior {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionCustomPatchesSecretGeneratorResourceBehavior, v)
	}
	*j = SpecDistributionCustomPatchesSecretGeneratorResourceBehavior(v)
	return nil
}

var enumValues_SpecDistributionModulesPolicyKyvernoValidationFailureAction = []interface{}{
	"Audit",
	"Enforce",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesPolicyKyvernoValidationFailureAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesPolicyKyvernoValidationFailureAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesPolicyKyvernoValidationFailureAction, v)
	}
	*j = SpecDistributionModulesPolicyKyvernoValidationFailureAction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesNetworkingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesNetworkingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesNetworkingType, v)
	}
	*j = SpecDistributionModulesNetworkingType(v)
	return nil
}

var enumValues_SpecDistributionModulesNetworkingType = []interface{}{
	"calico",
	"cilium",
	"none",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesMonitoring) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesMonitoring: required")
	}
	type Plain SpecDistributionModulesMonitoring
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesMonitoring(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesMonitoringType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesMonitoringType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesMonitoringType, v)
	}
	*j = SpecDistributionModulesMonitoringType(v)
	return nil
}

var enumValues_SpecDistributionModulesPolicyType = []interface{}{
	"kyverno",
	"gatekeeper",
	"none",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesPolicyType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesPolicyType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesPolicyType, v)
	}
	*j = SpecDistributionModulesPolicyType(v)
	return nil
}

var enumValues_SpecDistributionModulesMonitoringType = []interface{}{
	"prometheus",
	"prometheusAgent",
	"mimir",
	"none",
}

type TypesKubeResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *TypesKubeResourcesLimits `json:"limits,omitempty" yaml:"limits,omitempty" mapstructure:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *TypesKubeResourcesRequests `json:"requests,omitempty" yaml:"requests,omitempty" mapstructure:"requests,omitempty"`
}

type TypesKubeResourcesRequests struct {
	// The CPU request for the Pod, in cores or millicores. Examples: 500m, 1, 0.5
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty" mapstructure:"cpu,omitempty"`

	// The memory request for the Pod. Example: 500Mi, 1Gi
	Memory *TypesKubernetesQuantity `json:"memory,omitempty" yaml:"memory,omitempty" mapstructure:"memory,omitempty"`
}

type TypesKubeResourcesLimits struct {
	// The CPU limit for the Pod, in cores or millicores. Examples: 1000m, 2, 1.5
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty" mapstructure:"cpu,omitempty"`

	// The memory limit for the Pod. Example: 1Gi, 2Gi
	Memory *TypesKubernetesQuantity `json:"memory,omitempty" yaml:"memory,omitempty" mapstructure:"memory,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesPolicy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesPolicy: required")
	}
	type Plain SpecDistributionModulesPolicy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesPolicy(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesLogging) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesLogging: required")
	}
	type Plain SpecDistributionModulesLogging
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesLogging(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesLoggingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesLoggingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesLoggingType, v)
	}
	*j = SpecDistributionModulesLoggingType(v)
	return nil
}

var enumValues_SpecDistributionModulesTracingType = []interface{}{
	"tempo",
	"none",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesTracingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesTracingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesTracingType, v)
	}
	*j = SpecDistributionModulesTracingType(v)
	return nil
}

var enumValues_SpecDistributionModulesLoggingType = []interface{}{
	"loki",
	"opensearch",
	"none",
}

// Kubernetes resource quantity format. Examples: 50Gi, 100Mi, 1Ti
type TypesKubernetesQuantity string

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngress) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["baseDomain"]; !ok || v == nil {
		return fmt.Errorf("field baseDomain in SpecDistributionModulesIngress: required")
	}
	if v, ok := raw["nginx"]; !ok || v == nil {
		return fmt.Errorf("field nginx in SpecDistributionModulesIngress: required")
	}
	type Plain SpecDistributionModulesIngress
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.BaseDomain) > 253 {
		return fmt.Errorf("field %s length: must be <= %d", "baseDomain", 253)
	}
	*j = SpecDistributionModulesIngress(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesTracing) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesTracing: required")
	}
	type Plain SpecDistributionModulesTracing
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesTracing(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginx) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesIngressNginx: required")
	}
	type Plain SpecDistributionModulesIngressNginx
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressNginx(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModules) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["auth"]; !ok || v == nil {
		return fmt.Errorf("field auth in SpecDistributionModules: required")
	}
	if v, ok := raw["dr"]; !ok || v == nil {
		return fmt.Errorf("field dr in SpecDistributionModules: required")
	}
	if v, ok := raw["ingress"]; !ok || v == nil {
		return fmt.Errorf("field ingress in SpecDistributionModules: required")
	}
	if v, ok := raw["logging"]; !ok || v == nil {
		return fmt.Errorf("field logging in SpecDistributionModules: required")
	}
	if v, ok := raw["monitoring"]; !ok || v == nil {
		return fmt.Errorf("field monitoring in SpecDistributionModules: required")
	}
	if v, ok := raw["networking"]; !ok || v == nil {
		return fmt.Errorf("field networking in SpecDistributionModules: required")
	}
	if v, ok := raw["policy"]; !ok || v == nil {
		return fmt.Errorf("field policy in SpecDistributionModules: required")
	}
	type Plain SpecDistributionModules
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModules(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginxType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesIngressNginxType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesIngressNginxType, v)
	}
	*j = SpecDistributionModulesIngressNginxType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistribution) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["modules"]; !ok || v == nil {
		return fmt.Errorf("field modules in SpecDistribution: required")
	}
	type Plain SpecDistribution
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistribution(plain)
	return nil
}

var enumValues_SpecDistributionModulesIngressNginxType = []interface{}{
	"single",
	"dual",
	"none",
}
var enumValues_SpecInfrastructureIpxeServerAdvancedLogLevel = []interface{}{
	"debug",
	"info",
	"warning",
	"error",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureIpxeServerAdvancedLogLevel) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecInfrastructureIpxeServerAdvancedLogLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecInfrastructureIpxeServerAdvancedLogLevel, v)
	}
	*j = SpecInfrastructureIpxeServerAdvancedLogLevel(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginxTls) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["provider"]; !ok || v == nil {
		return fmt.Errorf("field provider in SpecDistributionModulesIngressNginxTls: required")
	}
	type Plain SpecDistributionModulesIngressNginxTls
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressNginxTls(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginxTlsProvider) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesIngressNginxTlsProvider {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesIngressNginxTlsProvider, v)
	}
	*j = SpecDistributionModulesIngressNginxTlsProvider(v)
	return nil
}

var enumValues_SpecDistributionModulesIngressNginxTlsProvider = []interface{}{
	"certManager",
	"secret",
	"none",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressCertManager) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["clusterIssuer"]; !ok || v == nil {
		return fmt.Errorf("field clusterIssuer in SpecDistributionModulesIngressCertManager: required")
	}
	type Plain SpecDistributionModulesIngressCertManager
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressCertManager(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressCertManagerClusterIssuer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email in SpecDistributionModulesIngressCertManagerClusterIssuer: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecDistributionModulesIngressCertManagerClusterIssuer: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesIngressCertManagerClusterIssuer: required")
	}
	type Plain SpecDistributionModulesIngressCertManagerClusterIssuer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressCertManagerClusterIssuer(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressCertManagerClusterIssuerType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesIngressCertManagerClusterIssuerType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesIngressCertManagerClusterIssuerType, v)
	}
	*j = SpecDistributionModulesIngressCertManagerClusterIssuerType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureIpxeServer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url in SpecInfrastructureIpxeServer: required")
	}
	type Plain SpecInfrastructureIpxeServer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureIpxeServer(plain)
	return nil
}

var enumValues_SpecDistributionModulesIngressCertManagerClusterIssuerType = []interface{}{
	"http01",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureKernelParameter) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecInfrastructureKernelParameter: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in SpecInfrastructureKernelParameter: required")
	}
	type Plain SpecInfrastructureKernelParameter
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.Name) > 256 {
		return fmt.Errorf("field %s length: must be <= %d", "name", 256)
	}
	if len(plain.Value) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "value", 1)
	}
	*j = SpecInfrastructureKernelParameter(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesDr) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesDr: required")
	}
	type Plain SpecDistributionModulesDr
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesDr(plain)
	return nil
}

var enumValues_SpecInfrastructureNodeArch = []interface{}{
	"x86-64",
	"arm64",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNodeArch) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecInfrastructureNodeArch {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecInfrastructureNodeArch, v)
	}
	*j = SpecInfrastructureNodeArch(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesDrVeleroSchedulesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecDistributionModulesDrVeleroSchedulesElem: required")
	}
	if v, ok := raw["schedule"]; !ok || v == nil {
		return fmt.Errorf("field schedule in SpecDistributionModulesDrVeleroSchedulesElem: required")
	}
	if v, ok := raw["ttl"]; !ok || v == nil {
		return fmt.Errorf("field ttl in SpecDistributionModulesDrVeleroSchedulesElem: required")
	}
	type Plain SpecDistributionModulesDrVeleroSchedulesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesDrVeleroSchedulesElem(plain)
	return nil
}

// Duration format with unit suffix. Examples: 720h, 15d, 30m, 5s
type TypesDuration string

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesDrVeleroS3) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SpecDistributionModulesDrVeleroS3
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.BucketName != nil && len(*plain.BucketName) < 3 {
		return fmt.Errorf("field %s length: must be >= %d", "bucketName", 3)
	}
	if plain.BucketName != nil && len(*plain.BucketName) > 63 {
		return fmt.Errorf("field %s length: must be <= %d", "bucketName", 63)
	}
	*j = SpecDistributionModulesDrVeleroS3(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNodeIscsi) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		return fmt.Errorf("field enabled in SpecInfrastructureNodeIscsi: required")
	}
	type Plain SpecInfrastructureNodeIscsi
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Config != nil && len(*plain.Config) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "config", 1)
	}
	*j = SpecInfrastructureNodeIscsi(plain)
	return nil
}

// MAC address in format XX:XX:XX:XX:XX:XX
type TypesMacAddress string

type TypesUri string

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNodeMultipath) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		return fmt.Errorf("field enabled in SpecInfrastructureNodeMultipath: required")
	}
	type Plain SpecInfrastructureNodeMultipath
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Config != nil && len(*plain.Config) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "config", 1)
	}
	*j = SpecInfrastructureNodeMultipath(plain)
	return nil
}

type TypesCidr string

type TypesIpAddress string

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesDrVeleroBackend) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesDrVeleroBackend {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesDrVeleroBackend, v)
	}
	*j = SpecDistributionModulesDrVeleroBackend(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNodeNetworkNameservers) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SpecInfrastructureNodeNetworkNameservers
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Search) > 6 {
		return fmt.Errorf("field %s length: must be <= %d", "search", 6)
	}
	*j = SpecInfrastructureNodeNetworkNameservers(plain)
	return nil
}

type TypesBondMode string

var enumValues_TypesBondMode = []interface{}{
	"balance-rr",
	"active-backup",
	"balance-xor",
	"broadcast",
	"802.3ad",
	"balance-tlb",
	"balance-alb",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesBondMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesBondMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesBondMode, v)
	}
	*j = TypesBondMode(v)
	return nil
}

const TypesBondModeBalanceRr TypesBondMode = "balance-rr"
const TypesBondModeActiveBackup TypesBondMode = "active-backup"
const TypesBondModeBalanceXor TypesBondMode = "balance-xor"
const TypesBondModeBroadcast TypesBondMode = "broadcast"
const TypesBondModeA8023Ad TypesBondMode = "802.3ad"
const TypesBondModeBalanceTlb TypesBondMode = "balance-tlb"
const TypesBondModeBalanceAlb TypesBondMode = "balance-alb"

var enumValues_SpecDistributionModulesDrVeleroBackend = []interface{}{
	"s3",
	"minio",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNodeNetworkBondParameters) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["mode"]; !ok || v == nil {
		return fmt.Errorf("field mode in SpecInfrastructureNodeNetworkBondParameters: required")
	}
	type Plain SpecInfrastructureNodeNetworkBondParameters
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureNodeNetworkBondParameters(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesDrType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesDrType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesDrType, v)
	}
	*j = SpecDistributionModulesDrType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNodeNetworkRoute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["to"]; !ok || v == nil {
		return fmt.Errorf("field to in SpecInfrastructureNodeNetworkRoute: required")
	}
	if v, ok := raw["via"]; !ok || v == nil {
		return fmt.Errorf("field via in SpecInfrastructureNodeNetworkRoute: required")
	}
	type Plain SpecInfrastructureNodeNetworkRoute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureNodeNetworkRoute(plain)
	return nil
}

var enumValues_SpecDistributionModulesDrType = []interface{}{
	"on-premises",
	"none",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNodeNetworkBond) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["interfaces"]; !ok || v == nil {
		return fmt.Errorf("field interfaces in SpecInfrastructureNodeNetworkBond: required")
	}
	if v, ok := raw["parameters"]; !ok || v == nil {
		return fmt.Errorf("field parameters in SpecInfrastructureNodeNetworkBond: required")
	}
	type Plain SpecInfrastructureNodeNetworkBond
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Interfaces != nil && len(plain.Interfaces) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "interfaces", 1)
	}
	*j = SpecInfrastructureNodeNetworkBond(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuth) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["provider"]; !ok || v == nil {
		return fmt.Errorf("field provider in SpecDistributionModulesAuth: required")
	}
	type Plain SpecDistributionModulesAuth
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuth(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthProvider) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesAuthProvider: required")
	}
	type Plain SpecDistributionModulesAuthProvider
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuthProvider(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthProviderType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesAuthProviderType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesAuthProviderType, v)
	}
	*j = SpecDistributionModulesAuthProviderType(v)
	return nil
}

var enumValues_SpecDistributionModulesAuthProviderType = []interface{}{
	"none",
	"basicAuth",
	"sso",
}

// Unix device path. Example: /dev/sda, /dev/nvme0n1
type TypesDevicePath string

type TypesFilesystemType string

var enumValues_TypesFilesystemType = []interface{}{
	"ext4",
	"xfs",
	"btrfs",
	"ext3",
	"vfat",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesFilesystemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesFilesystemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesFilesystemType, v)
	}
	*j = TypesFilesystemType(v)
	return nil
}

const TypesFilesystemTypeExt4 TypesFilesystemType = "ext4"
const TypesFilesystemTypeXfs TypesFilesystemType = "xfs"
const TypesFilesystemTypeBtrfs TypesFilesystemType = "btrfs"
const TypesFilesystemTypeExt3 TypesFilesystemType = "ext3"
const TypesFilesystemTypeVfat TypesFilesystemType = "vfat"

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionCustomPatchesSecretGeneratorResource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecDistributionCustomPatchesSecretGeneratorResource: required")
	}
	type Plain SpecDistributionCustomPatchesSecretGeneratorResource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionCustomPatchesSecretGeneratorResource(plain)
	return nil
}

var enumValues_SpecInfrastructureNodeStorageFilesystemMountOptionsElem = []interface{}{
	"noatime",
	"nodiratime",
	"relatime",
	"strictatime",
	"nodev",
	"nosuid",
	"noexec",
	"ro",
	"rw",
	"sync",
	"async",
	"discard",
	"nodiscard",
	"defaults",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNodeStorageFilesystemMountOptionsElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecInfrastructureNodeStorageFilesystemMountOptionsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecInfrastructureNodeStorageFilesystemMountOptionsElem, v)
	}
	*j = SpecInfrastructureNodeStorageFilesystemMountOptionsElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesNetworking) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesNetworking: required")
	}
	type Plain SpecDistributionModulesNetworking
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesNetworking(plain)
	return nil
}

var enumValues_SpecDistributionCustomPatchesSecretGeneratorResourceBehavior = []interface{}{
	"create",
	"replace",
	"merge",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionCustomPatchesConfigMapGeneratorResource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecDistributionCustomPatchesConfigMapGeneratorResource: required")
	}
	type Plain SpecDistributionCustomPatchesConfigMapGeneratorResource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionCustomPatchesConfigMapGeneratorResource(plain)
	return nil
}

const SpecInfrastructureNodeStorageFilesystemMountOptionsElemStrictatime SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "strictatime"

type TypesKubeLabels map[string]string

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior, v)
	}
	*j = SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior(v)
	return nil
}

var enumValues_SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior = []interface{}{
	"create",
	"replace",
	"merge",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesKubeToleration) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["effect"]; !ok || v == nil {
		return fmt.Errorf("field effect in TypesKubeToleration: required")
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key in TypesKubeToleration: required")
	}
	type Plain TypesKubeToleration
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TypesKubeToleration(plain)
	return nil
}

type TypesKubeToleration struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect TypesKubeTolerationEffect `json:"effect" yaml:"effect" mapstructure:"effect"`

	// The key of the toleration
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *TypesKubeTolerationOperator `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// The value of the toleration
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

const SpecInfrastructureNodeStorageFilesystemMountOptionsElemSync SpecInfrastructureNodeStorageFilesystemMountOptionsElem = "sync"
const TypesKubeTolerationOperatorEqual TypesKubeTolerationOperator = "Equal"
const TypesKubeTolerationOperatorExists TypesKubeTolerationOperator = "Exists"

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesKubeTolerationOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesKubeTolerationOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesKubeTolerationOperator, v)
	}
	*j = TypesKubeTolerationOperator(v)
	return nil
}

var enumValues_TypesKubeTolerationOperator = []interface{}{
	"Exists",
	"Equal",
}

type TypesKubeTolerationOperator string

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNodeStorageFilesystem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["format"]; !ok || v == nil {
		return fmt.Errorf("field format in SpecInfrastructureNodeStorageFilesystem: required")
	}
	if v, ok := raw["label"]; !ok || v == nil {
		return fmt.Errorf("field label in SpecInfrastructureNodeStorageFilesystem: required")
	}
	if v, ok := raw["mountPoint"]; !ok || v == nil {
		return fmt.Errorf("field mountPoint in SpecInfrastructureNodeStorageFilesystem: required")
	}
	type Plain SpecInfrastructureNodeStorageFilesystem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Label) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "label", 1)
	}
	if len(plain.Label) > 12 {
		return fmt.Errorf("field %s length: must be <= %d", "label", 12)
	}
	*j = SpecInfrastructureNodeStorageFilesystem(plain)
	return nil
}

// Partition definition with filesystem and mount options.
type SpecInfrastructureNodeStoragePartition struct {
	// Filesystem corresponds to the JSON schema field "filesystem".
	Filesystem SpecInfrastructureNodeStorageFilesystem `json:"filesystem" yaml:"filesystem" mapstructure:"filesystem"`

	// Partition label. Example: etcd-data
	Label string `json:"label" yaml:"label" mapstructure:"label"`

	// Partition number. Example: 1
	Number int `json:"number" yaml:"number" mapstructure:"number"`

	// Partition size in MiB. Use 0 to use all available space.
	SizeMiB int `json:"sizeMiB" yaml:"sizeMiB" mapstructure:"sizeMiB"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNodeStoragePartition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["filesystem"]; !ok || v == nil {
		return fmt.Errorf("field filesystem in SpecInfrastructureNodeStoragePartition: required")
	}
	if v, ok := raw["label"]; !ok || v == nil {
		return fmt.Errorf("field label in SpecInfrastructureNodeStoragePartition: required")
	}
	if v, ok := raw["number"]; !ok || v == nil {
		return fmt.Errorf("field number in SpecInfrastructureNodeStoragePartition: required")
	}
	if v, ok := raw["sizeMiB"]; !ok || v == nil {
		return fmt.Errorf("field sizeMiB in SpecInfrastructureNodeStoragePartition: required")
	}
	type Plain SpecInfrastructureNodeStoragePartition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Label) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "label", 1)
	}
	*j = SpecInfrastructureNodeStoragePartition(plain)
	return nil
}

const TypesKubeTolerationEffectNoExecute TypesKubeTolerationEffect = "NoExecute"

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNodeStorageDisk) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["device"]; !ok || v == nil {
		return fmt.Errorf("field device in SpecInfrastructureNodeStorageDisk: required")
	}
	if v, ok := raw["partitions"]; !ok || v == nil {
		return fmt.Errorf("field partitions in SpecInfrastructureNodeStorageDisk: required")
	}
	type Plain SpecInfrastructureNodeStorageDisk
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Partitions != nil && len(plain.Partitions) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "partitions", 1)
	}
	*j = SpecInfrastructureNodeStorageDisk(plain)
	return nil
}

const TypesKubeTolerationEffectPreferNoSchedule TypesKubeTolerationEffect = "PreferNoSchedule"

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNodeStorage) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["installDisk"]; !ok || v == nil {
		return fmt.Errorf("field installDisk in SpecInfrastructureNodeStorage: required")
	}
	type Plain SpecInfrastructureNodeStorage
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureNodeStorage(plain)
	return nil
}

const TypesKubeTolerationEffectNoSchedule TypesKubeTolerationEffect = "NoSchedule"

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["hostname"]; !ok || v == nil {
		return fmt.Errorf("field hostname in SpecInfrastructureNode: required")
	}
	if v, ok := raw["macAddress"]; !ok || v == nil {
		return fmt.Errorf("field macAddress in SpecInfrastructureNode: required")
	}
	if v, ok := raw["network"]; !ok || v == nil {
		return fmt.Errorf("field network in SpecInfrastructureNode: required")
	}
	if v, ok := raw["storage"]; !ok || v == nil {
		return fmt.Errorf("field storage in SpecInfrastructureNode: required")
	}
	type Plain SpecInfrastructureNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["arch"]; !ok || v == nil {
		plain.Arch = "x86-64"
	}
	if len(plain.Hostname) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "hostname", 1)
	}
	*j = SpecInfrastructureNode(plain)
	return nil
}

// HTTP/HTTPS proxy configuration for the infrastructure nodes.
type SpecInfrastructureProxy struct {
	// The HTTP proxy URL. Example: http://proxy.example.com:3128
	Http *TypesUri `json:"http,omitempty" yaml:"http,omitempty" mapstructure:"http,omitempty"`

	// The HTTPS proxy URL. Example: https://proxy.example.com:3128
	Https *TypesUri `json:"https,omitempty" yaml:"https,omitempty" mapstructure:"https,omitempty"`

	// Comma-separated list of hosts that should not use the HTTP(S) proxy. Example:
	// localhost,127.0.0.1,10.0.0.0/8,.example.com
	NoProxy *string `json:"noProxy,omitempty" yaml:"noProxy,omitempty" mapstructure:"noProxy,omitempty"`
}

// SSH credentials for node access.
type SpecInfrastructureSSH struct {
	// Path to the SSH private key. Example: ~/.ssh/id_ed25519_production
	KeyPath string `json:"keyPath" yaml:"keyPath" mapstructure:"keyPath"`

	// SSH username. Example: core
	Username string `json:"username" yaml:"username" mapstructure:"username"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureSSH) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["keyPath"]; !ok || v == nil {
		return fmt.Errorf("field keyPath in SpecInfrastructureSSH: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username in SpecInfrastructureSSH: required")
	}
	type Plain SpecInfrastructureSSH
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Username) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "username", 1)
	}
	*j = SpecInfrastructureSSH(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesKubeTolerationEffect) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesKubeTolerationEffect {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesKubeTolerationEffect, v)
	}
	*j = TypesKubeTolerationEffect(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructure) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nodes"]; !ok || v == nil {
		return fmt.Errorf("field nodes in SpecInfrastructure: required")
	}
	if v, ok := raw["ssh"]; !ok || v == nil {
		return fmt.Errorf("field ssh in SpecInfrastructure: required")
	}
	type Plain SpecInfrastructure
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Nodes != nil && len(plain.Nodes) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "nodes", 1)
	}
	*j = SpecInfrastructure(plain)
	return nil
}

// API server configuration for certificate Subject Alternative Names.
type SpecKubernetesAdvancedApiServer struct {
	// Additional Subject Alternative Names for the API server certificate.
	CertSANs []string `json:"certSANs,omitempty" yaml:"certSANs,omitempty" mapstructure:"certSANs,omitempty"`
}

// Cloud provider integration. Ref:
// https://kubernetes.io/docs/concepts/architecture/cloud-controller/
type SpecKubernetesAdvancedCloud struct {
	// Cloud provider type. Example: external
	Provider *string `json:"provider,omitempty" yaml:"provider,omitempty" mapstructure:"provider,omitempty"`
}

type SpecKubernetesAdvancedContainerdRegistryConfigsElem struct {
	// Skip TLS verification for this registry.
	InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty" yaml:"insecureSkipVerify,omitempty" mapstructure:"insecureSkipVerify,omitempty"`

	// Registry password.
	Password *string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// Registry hostname and optional path. Example: registry.example.com,
	// registry.example.com:5000/myrepo
	Registry string `json:"registry" yaml:"registry" mapstructure:"registry"`

	// Registry username.
	Username *string `json:"username,omitempty" yaml:"username,omitempty" mapstructure:"username,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesAdvancedContainerdRegistryConfigsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["registry"]; !ok || v == nil {
		return fmt.Errorf("field registry in SpecKubernetesAdvancedContainerdRegistryConfigsElem: required")
	}
	type Plain SpecKubernetesAdvancedContainerdRegistryConfigsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesAdvancedContainerdRegistryConfigsElem(plain)
	return nil
}

// Container runtime registry configuration.
type SpecKubernetesAdvancedContainerd struct {
	// RegistryConfigs corresponds to the JSON schema field "registryConfigs".
	RegistryConfigs []SpecKubernetesAdvancedContainerdRegistryConfigsElem `json:"registryConfigs,omitempty" yaml:"registryConfigs,omitempty" mapstructure:"registryConfigs,omitempty"`
}

// Encryption at rest configuration. Ref:
// https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/
type SpecKubernetesAdvancedEncryption struct {
	// EncryptionConfiguration YAML content (must be valid YAML with proper
	// structure).
	Configuration *string `json:"configuration,omitempty" yaml:"configuration,omitempty" mapstructure:"configuration,omitempty"`

	// TLS cipher suites for the API server. Only secure cipher suites allowed.
	TlsCipherSuites []string `json:"tlsCipherSuites,omitempty" yaml:"tlsCipherSuites,omitempty" mapstructure:"tlsCipherSuites,omitempty"`

	// TLS cipher suites for kubelet. Only secure cipher suites allowed.
	TlsCipherSuitesKubelet []string `json:"tlsCipherSuitesKubelet,omitempty" yaml:"tlsCipherSuitesKubelet,omitempty" mapstructure:"tlsCipherSuitesKubelet,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesAdvancedEncryption) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SpecKubernetesAdvancedEncryption
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Configuration != nil && len(*plain.Configuration) < 50 {
		return fmt.Errorf("field %s length: must be >= %d", "configuration", 50)
	}
	*j = SpecKubernetesAdvancedEncryption(plain)
	return nil
}

// Kubelet configuration parameters. Ref:
// https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/
type SpecKubernetesKubeletConfiguration struct {
	// Maximum number of pods per node. Example: 200
	MaxPods *int `json:"maxPods,omitempty" yaml:"maxPods,omitempty" mapstructure:"maxPods,omitempty"`

	// Maximum number of PIDs per pod. Example: 8192
	PodPidsLimit *int `json:"podPidsLimit,omitempty" yaml:"podPidsLimit,omitempty" mapstructure:"podPidsLimit,omitempty"`
}

// OIDC authentication provider configuration. Ref:
// https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens
type SpecKubernetesAdvancedOidc struct {
	// OIDC client ID.
	ClientId *string `json:"client_id,omitempty" yaml:"client_id,omitempty" mapstructure:"client_id,omitempty"`

	// OIDC groups claim.
	GroupsClaim *string `json:"groups_claim,omitempty" yaml:"groups_claim,omitempty" mapstructure:"groups_claim,omitempty"`

	// Prefix for OIDC groups.
	GroupsPrefix *string `json:"groups_prefix,omitempty" yaml:"groups_prefix,omitempty" mapstructure:"groups_prefix,omitempty"`

	// OIDC issuer URL.
	IssuerUrl *TypesUri `json:"issuer_url,omitempty" yaml:"issuer_url,omitempty" mapstructure:"issuer_url,omitempty"`

	// OIDC username claim.
	UsernameClaim *string `json:"username_claim,omitempty" yaml:"username_claim,omitempty" mapstructure:"username_claim,omitempty"`

	// Prefix for OIDC usernames.
	UsernamePrefix *string `json:"username_prefix,omitempty" yaml:"username_prefix,omitempty" mapstructure:"username_prefix,omitempty"`
}

// User certificate generation configuration.
type SpecKubernetesAdvancedUsers struct {
	// List of user names for certificate generation.
	Names []string `json:"names,omitempty" yaml:"names,omitempty" mapstructure:"names,omitempty"`

	// Organization name for user certificates.
	Org *string `json:"org,omitempty" yaml:"org,omitempty" mapstructure:"org,omitempty"`
}

// Advanced Kubernetes cluster configuration.
type SpecKubernetesAdvanced struct {
	// API server configuration for certificate Subject Alternative Names.
	ApiServer *SpecKubernetesAdvancedApiServer `json:"apiServer,omitempty" yaml:"apiServer,omitempty" mapstructure:"apiServer,omitempty"`

	// Cloud provider integration. Ref:
	// https://kubernetes.io/docs/concepts/architecture/cloud-controller/
	Cloud *SpecKubernetesAdvancedCloud `json:"cloud,omitempty" yaml:"cloud,omitempty" mapstructure:"cloud,omitempty"`

	// Container runtime registry configuration.
	Containerd *SpecKubernetesAdvancedContainerd `json:"containerd,omitempty" yaml:"containerd,omitempty" mapstructure:"containerd,omitempty"`

	// Encryption at rest configuration. Ref:
	// https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/
	Encryption *SpecKubernetesAdvancedEncryption `json:"encryption,omitempty" yaml:"encryption,omitempty" mapstructure:"encryption,omitempty"`

	// KubeletConfiguration corresponds to the JSON schema field
	// "kubeletConfiguration".
	KubeletConfiguration *SpecKubernetesKubeletConfiguration `json:"kubeletConfiguration,omitempty" yaml:"kubeletConfiguration,omitempty" mapstructure:"kubeletConfiguration,omitempty"`

	// OIDC authentication provider configuration. Ref:
	// https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens
	Oidc *SpecKubernetesAdvancedOidc `json:"oidc,omitempty" yaml:"oidc,omitempty" mapstructure:"oidc,omitempty"`

	// User certificate generation configuration.
	Users *SpecKubernetesAdvancedUsers `json:"users,omitempty" yaml:"users,omitempty" mapstructure:"users,omitempty"`
}

// A member node reference with optional IP override.
type SpecKubernetesMember struct {
	// Hostname that must match an infrastructure node. Example:
	// ctrl01.k8s.example.com
	Hostname string `json:"hostname" yaml:"hostname" mapstructure:"hostname"`

	// Optional IP address. If not specified, it is inferred from the node's network
	// configuration.
	Ip *TypesIpAddress `json:"ip,omitempty" yaml:"ip,omitempty" mapstructure:"ip,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesMember) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["hostname"]; !ok || v == nil {
		return fmt.Errorf("field hostname in SpecKubernetesMember: required")
	}
	type Plain SpecKubernetesMember
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Hostname) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "hostname", 1)
	}
	*j = SpecKubernetesMember(plain)
	return nil
}

// Control plane configuration.
type SpecKubernetesControlPlane struct {
	// The address for the Kubernetes control plane with port. Example:
	// k8s-api.example.com:6443
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// KubeletConfiguration corresponds to the JSON schema field
	// "kubeletConfiguration".
	KubeletConfiguration *SpecKubernetesKubeletConfiguration `json:"kubeletConfiguration,omitempty" yaml:"kubeletConfiguration,omitempty" mapstructure:"kubeletConfiguration,omitempty"`

	// Control plane member nodes.
	Members []SpecKubernetesMember `json:"members" yaml:"members" mapstructure:"members"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesControlPlane) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in SpecKubernetesControlPlane: required")
	}
	if v, ok := raw["members"]; !ok || v == nil {
		return fmt.Errorf("field members in SpecKubernetesControlPlane: required")
	}
	type Plain SpecKubernetesControlPlane
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Members != nil && len(plain.Members) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "members", 1)
	}
	*j = SpecKubernetesControlPlane(plain)
	return nil
}

// etcd cluster configuration. Ref:
// https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/
type SpecKubernetesEtcd struct {
	// etcd member nodes.
	Members []SpecKubernetesMember `json:"members" yaml:"members" mapstructure:"members"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesEtcd) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["members"]; !ok || v == nil {
		return fmt.Errorf("field members in SpecKubernetesEtcd: required")
	}
	type Plain SpecKubernetesEtcd
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Members != nil && len(plain.Members) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "members", 1)
	}
	*j = SpecKubernetesEtcd(plain)
	return nil
}

// Load balancer configuration for high-availability API server access. Uses
// HAProxy for load balancing and keepalived for VIP failover.
type SpecKubernetesLoadBalancers struct {
	// Enable load balancer configuration. When true, HAProxy and keepalived will be
	// configured.
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Load balancer member nodes. These nodes will run HAProxy and keepalived.
	Members []SpecKubernetesMember `json:"members" yaml:"members" mapstructure:"members"`

	// Virtual IP address managed by keepalived for HA. This IP will be used as the
	// control plane address. Example: 192.168.1.10
	VirtualIP TypesIpAddress `json:"virtualIP" yaml:"virtualIP" mapstructure:"virtualIP"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesLoadBalancers) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["members"]; !ok || v == nil {
		return fmt.Errorf("field members in SpecKubernetesLoadBalancers: required")
	}
	if v, ok := raw["virtualIP"]; !ok || v == nil {
		return fmt.Errorf("field virtualIP in SpecKubernetesLoadBalancers: required")
	}
	type Plain SpecKubernetesLoadBalancers
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		plain.Enabled = true
	}
	if plain.Members != nil && len(plain.Members) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "members", 1)
	}
	*j = SpecKubernetesLoadBalancers(plain)
	return nil
}

// Kubernetes network configuration. Ref:
// https://kubernetes.io/docs/concepts/cluster-administration/networking/
type SpecKubernetesNetworking struct {
	// Pod network CIDR. Example: 10.244.0.0/16
	PodCIDR TypesCidr `json:"podCIDR" yaml:"podCIDR" mapstructure:"podCIDR"`

	// Service network CIDR. Example: 10.96.0.0/12
	ServiceCIDR TypesCidr `json:"serviceCIDR" yaml:"serviceCIDR" mapstructure:"serviceCIDR"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNetworking) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["podCIDR"]; !ok || v == nil {
		return fmt.Errorf("field podCIDR in SpecKubernetesNetworking: required")
	}
	if v, ok := raw["serviceCIDR"]; !ok || v == nil {
		return fmt.Errorf("field serviceCIDR in SpecKubernetesNetworking: required")
	}
	type Plain SpecKubernetesNetworking
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNetworking(plain)
	return nil
}

type TypesKubeAnnotations map[string]string

type TypesKubeLabels_1 map[string]string

type TypesKubeTaintsEffect string

var enumValues_TypesKubeTaintsEffect = []interface{}{
	"NoSchedule",
	"PreferNoSchedule",
	"NoExecute",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesKubeTaintsEffect) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesKubeTaintsEffect {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesKubeTaintsEffect, v)
	}
	*j = TypesKubeTaintsEffect(v)
	return nil
}

const TypesKubeTaintsEffectNoSchedule TypesKubeTaintsEffect = "NoSchedule"
const TypesKubeTaintsEffectPreferNoSchedule TypesKubeTaintsEffect = "PreferNoSchedule"
const TypesKubeTaintsEffectNoExecute TypesKubeTaintsEffect = "NoExecute"

type TypesKubeTaints struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect TypesKubeTaintsEffect `json:"effect" yaml:"effect" mapstructure:"effect"`

	// Key corresponds to the JSON schema field "key".
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesKubeTaints) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["effect"]; !ok || v == nil {
		return fmt.Errorf("field effect in TypesKubeTaints: required")
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key in TypesKubeTaints: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in TypesKubeTaints: required")
	}
	type Plain TypesKubeTaints
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TypesKubeTaints(plain)
	return nil
}

// A group of worker nodes with common labels, taints, and annotations. Ref:
// https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
type SpecKubernetesNodeGroup struct {
	// Kubernetes annotations to apply to nodes in this group.
	Annotations TypesKubeAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// KubeletConfiguration corresponds to the JSON schema field
	// "kubeletConfiguration".
	KubeletConfiguration *SpecKubernetesKubeletConfiguration `json:"kubeletConfiguration,omitempty" yaml:"kubeletConfiguration,omitempty" mapstructure:"kubeletConfiguration,omitempty"`

	// Kubernetes labels to apply to nodes in this group.
	Labels TypesKubeLabels_1 `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Node group name identifier. Example: infra_workers
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Nodes in this group.
	Nodes []SpecKubernetesMember `json:"nodes" yaml:"nodes" mapstructure:"nodes"`

	// Kubernetes taints to apply to nodes in this group.
	Taints []TypesKubeTaints `json:"taints,omitempty" yaml:"taints,omitempty" mapstructure:"taints,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodeGroup) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecKubernetesNodeGroup: required")
	}
	if v, ok := raw["nodes"]; !ok || v == nil {
		return fmt.Errorf("field nodes in SpecKubernetesNodeGroup: required")
	}
	type Plain SpecKubernetesNodeGroup
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if plain.Nodes != nil && len(plain.Nodes) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "nodes", 1)
	}
	*j = SpecKubernetesNodeGroup(plain)
	return nil
}

// Kubernetes cluster configuration including control plane, etcd, and worker
// nodes.
type SpecKubernetes struct {
	// Advanced corresponds to the JSON schema field "advanced".
	Advanced *SpecKubernetesAdvanced `json:"advanced,omitempty" yaml:"advanced,omitempty" mapstructure:"advanced,omitempty"`

	// ControlPlane corresponds to the JSON schema field "controlPlane".
	ControlPlane SpecKubernetesControlPlane `json:"controlPlane" yaml:"controlPlane" mapstructure:"controlPlane"`

	// Etcd corresponds to the JSON schema field "etcd".
	Etcd SpecKubernetesEtcd `json:"etcd" yaml:"etcd" mapstructure:"etcd"`

	// LoadBalancers corresponds to the JSON schema field "loadBalancers".
	LoadBalancers *SpecKubernetesLoadBalancers `json:"loadBalancers,omitempty" yaml:"loadBalancers,omitempty" mapstructure:"loadBalancers,omitempty"`

	// Networking corresponds to the JSON schema field "networking".
	Networking SpecKubernetesNetworking `json:"networking" yaml:"networking" mapstructure:"networking"`

	// Worker node groups with labels, taints, and annotations.
	NodeGroups []SpecKubernetesNodeGroup `json:"nodeGroups,omitempty" yaml:"nodeGroups,omitempty" mapstructure:"nodeGroups,omitempty"`

	// Kubernetes version for sysext packages. Determines versions of containerd,
	// kubernetes, and other components from installer defaults. Example: 1.33.4
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["controlPlane"]; !ok || v == nil {
		return fmt.Errorf("field controlPlane in SpecKubernetes: required")
	}
	if v, ok := raw["etcd"]; !ok || v == nil {
		return fmt.Errorf("field etcd in SpecKubernetes: required")
	}
	if v, ok := raw["networking"]; !ok || v == nil {
		return fmt.Errorf("field networking in SpecKubernetes: required")
	}
	type Plain SpecKubernetes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetes(plain)
	return nil
}

type SpecPluginsHelmReleasesElemSetElem struct {
	// The name of the set
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The value of the set
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecPluginsHelmReleasesElemSetElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecPluginsHelmReleasesElemSetElem: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in SpecPluginsHelmReleasesElemSetElem: required")
	}
	type Plain SpecPluginsHelmReleasesElemSetElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecPluginsHelmReleasesElemSetElem(plain)
	return nil
}

type SpecPluginsHelmReleases []struct {
	// The chart of the release
	Chart string `json:"chart" yaml:"chart" mapstructure:"chart"`

	// Disable running `helm diff` validation when installing the plugin, it will
	// still be done when upgrading.
	DisableValidationOnInstall *bool `json:"disableValidationOnInstall,omitempty" yaml:"disableValidationOnInstall,omitempty" mapstructure:"disableValidationOnInstall,omitempty"`

	// The name of the release
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The namespace of the release
	Namespace string `json:"namespace" yaml:"namespace" mapstructure:"namespace"`

	// Set corresponds to the JSON schema field "set".
	Set []SpecPluginsHelmReleasesElemSetElem `json:"set,omitempty" yaml:"set,omitempty" mapstructure:"set,omitempty"`

	// The values of the release
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`

	// The version of the release
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type SpecPluginsHelmRepositories []struct {
	// The name of the repository
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The url of the repository
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

type SpecPluginsHelm struct {
	// Releases corresponds to the JSON schema field "releases".
	Releases SpecPluginsHelmReleases `json:"releases,omitempty" yaml:"releases,omitempty" mapstructure:"releases,omitempty"`

	// Repositories corresponds to the JSON schema field "repositories".
	Repositories SpecPluginsHelmRepositories `json:"repositories,omitempty" yaml:"repositories,omitempty" mapstructure:"repositories,omitempty"`
}

type SpecPluginsKustomize []struct {
	// The folder of the kustomize plugin
	Folder string `json:"folder" yaml:"folder" mapstructure:"folder"`

	// The name of the kustomize plugin. A lowercase RFC 1123 subdomain must consist
	// of lower case alphanumeric characters, '-' or '.', and must start and end with
	// an alphanumeric character (e.g. 'example.com', 'local-storage')
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type SpecPlugins struct {
	// Helm corresponds to the JSON schema field "helm".
	Helm *SpecPluginsHelm `json:"helm,omitempty" yaml:"helm,omitempty" mapstructure:"helm,omitempty"`

	// Kustomize corresponds to the JSON schema field "kustomize".
	Kustomize SpecPluginsKustomize `json:"kustomize,omitempty" yaml:"kustomize,omitempty" mapstructure:"kustomize,omitempty"`
}

var enumValues_TypesKubeTolerationEffect = []interface{}{
	"NoSchedule",
	"PreferNoSchedule",
	"NoExecute",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Spec) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["distribution"]; !ok || v == nil {
		return fmt.Errorf("field distribution in Spec: required")
	}
	if v, ok := raw["distributionVersion"]; !ok || v == nil {
		return fmt.Errorf("field distributionVersion in Spec: required")
	}
	if v, ok := raw["infrastructure"]; !ok || v == nil {
		return fmt.Errorf("field infrastructure in Spec: required")
	}
	if v, ok := raw["kubernetes"]; !ok || v == nil {
		return fmt.Errorf("field kubernetes in Spec: required")
	}
	type Plain Spec
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.DistributionVersion) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "distributionVersion", 1)
	}
	*j = Spec(plain)
	return nil
}

type TypesEnvRef string

type TypesFileRef string

type TypesSemVer string

type TypesSshPubKey string

type TypesTcpPort int

type TypesKubeTolerationEffect string

var enumValues_ImmutableKfdV1Alpha2Kind = []interface{}{
	"Immutable",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImmutableKfdV1Alpha2Kind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ImmutableKfdV1Alpha2Kind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ImmutableKfdV1Alpha2Kind, v)
	}
	*j = ImmutableKfdV1Alpha2Kind(v)
	return nil
}

type TypesKubeNodeSelector map[string]string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Metadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Metadata: required")
	}
	type Plain Metadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.Name) > 56 {
		return fmt.Errorf("field %s length: must be <= %d", "name", 56)
	}
	*j = Metadata(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImmutableKfdV1Alpha2) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["apiVersion"]; !ok || v == nil {
		return fmt.Errorf("field apiVersion in ImmutableKfdV1Alpha2: required")
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind in ImmutableKfdV1Alpha2: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata in ImmutableKfdV1Alpha2: required")
	}
	if v, ok := raw["spec"]; !ok || v == nil {
		return fmt.Errorf("field spec in ImmutableKfdV1Alpha2: required")
	}
	type Plain ImmutableKfdV1Alpha2
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImmutableKfdV1Alpha2(plain)
	return nil
}
