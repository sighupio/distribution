// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schemas

import "fmt"
import "encoding/json"
import "reflect"

// A Fury Cluster deployed through AWS's Elastic Kubernetes Service
type EksclusterKfdV1Alpha2Json struct {
	// ApiVersion corresponds to the JSON schema field "apiVersion".
	ApiVersion string `json:"apiVersion" yaml:"apiVersion"`

	// Kind corresponds to the JSON schema field "kind".
	Kind EksclusterKfdV1Alpha2JsonKind `json:"kind" yaml:"kind"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata" yaml:"metadata"`

	// Spec corresponds to the JSON schema field "spec".
	Spec Spec `json:"spec" yaml:"spec"`
}

type EksclusterKfdV1Alpha2JsonKind string

const EksclusterKfdV1Alpha2JsonKindEKSCluster EksclusterKfdV1Alpha2JsonKind = "EKSCluster"

type Metadata struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name"`
}

type Spec struct {
	// Distribution corresponds to the JSON schema field "distribution".
	Distribution *SpecDistribution_1 `json:"distribution,omitempty" yaml:"distribution,omitempty"`

	// DistributionVersion corresponds to the JSON schema field "distributionVersion".
	DistributionVersion TypesSemVer `json:"distributionVersion" yaml:"distributionVersion"`

	// Infrastructure corresponds to the JSON schema field "infrastructure".
	Infrastructure *SpecInfrastructure_1 `json:"infrastructure,omitempty" yaml:"infrastructure,omitempty"`

	// Kubernetes corresponds to the JSON schema field "kubernetes".
	Kubernetes SpecKubernetes `json:"kubernetes" yaml:"kubernetes"`

	// Tags corresponds to the JSON schema field "tags".
	Tags TypesAwsTags `json:"tags,omitempty" yaml:"tags,omitempty"`

	// ToolsConfiguration corresponds to the JSON schema field "toolsConfiguration".
	ToolsConfiguration SpecToolsConfiguration_1 `json:"toolsConfiguration" yaml:"toolsConfiguration"`
}

type SpecDistributionCommonProvider_1 struct {
	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`
}

type SpecDistributionCommon_1 struct {
	// NodeSelector corresponds to the JSON schema field "nodeSelector".
	NodeSelector TypesKubeNodeSelector `json:"nodeSelector" yaml:"nodeSelector"`

	// Provider corresponds to the JSON schema field "provider".
	Provider SpecDistributionCommonProvider_1 `json:"provider" yaml:"provider"`

	// RelativeVendorPath corresponds to the JSON schema field "relativeVendorPath".
	RelativeVendorPath string `json:"relativeVendorPath" yaml:"relativeVendorPath"`

	// Tolerations corresponds to the JSON schema field "tolerations".
	Tolerations []TypesKubeToleration `json:"tolerations" yaml:"tolerations"`
}

type SpecDistributionModulesAuthDex_1 struct {
	// Connectors corresponds to the JSON schema field "connectors".
	Connectors []interface{} `json:"connectors,omitempty" yaml:"connectors,omitempty"`
}

type SpecDistributionModulesAuthOverridesIngresses map[string]SpecDistributionModulesAuthOverridesIngresses_1

type SpecDistributionModulesAuthOverridesIngresses_1 struct {
	// Host corresponds to the JSON schema field "host".
	Host string `json:"host" yaml:"host"`

	// IngressClass corresponds to the JSON schema field "ingressClass".
	IngressClass string `json:"ingressClass" yaml:"ingressClass"`
}

type SpecDistributionModulesAuthOverrides_1 struct {
	// Ingresses corresponds to the JSON schema field "ingresses".
	Ingresses SpecDistributionModulesAuthOverridesIngresses `json:"ingresses,omitempty" yaml:"ingresses,omitempty"`

	// NodeSelector corresponds to the JSON schema field "nodeSelector".
	NodeSelector TypesKubeNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`

	// Tolerations corresponds to the JSON schema field "tolerations".
	Tolerations []TypesKubeToleration `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
}

type SpecDistributionModulesAuthPomeriumSecrets_1 struct {
	// COOKIESECRET corresponds to the JSON schema field "COOKIE_SECRET".
	COOKIESECRET string `json:"COOKIE_SECRET" yaml:"COOKIE_SECRET"`

	// IDPCLIENTSECRET corresponds to the JSON schema field "IDP_CLIENT_SECRET".
	IDPCLIENTSECRET string `json:"IDP_CLIENT_SECRET" yaml:"IDP_CLIENT_SECRET"`

	// SHAREDSECRET corresponds to the JSON schema field "SHARED_SECRET".
	SHAREDSECRET string `json:"SHARED_SECRET" yaml:"SHARED_SECRET"`
}

type SpecDistributionModulesAuthPomerium_1 struct {
	// Secrets corresponds to the JSON schema field "secrets".
	Secrets SpecDistributionModulesAuthPomeriumSecrets_1 `json:"secrets" yaml:"secrets"`
}

type SpecDistributionModulesAuthProviderBasicAuth_1 struct {
	// Password corresponds to the JSON schema field "password".
	Password string `json:"password" yaml:"password"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username" yaml:"username"`
}

type SpecDistributionModulesAuthProviderType string

const SpecDistributionModulesAuthProviderTypeBasicAuth SpecDistributionModulesAuthProviderType = "basicAuth"
const SpecDistributionModulesAuthProviderTypeNone SpecDistributionModulesAuthProviderType = "none"
const SpecDistributionModulesAuthProviderTypeSso SpecDistributionModulesAuthProviderType = "sso"

type SpecDistributionModulesAuthProvider_1 struct {
	// BasicAuth corresponds to the JSON schema field "basicAuth".
	BasicAuth *SpecDistributionModulesAuthProviderBasicAuth_1 `json:"basicAuth,omitempty" yaml:"basicAuth,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type SpecDistributionModulesAuthProviderType `json:"type" yaml:"type"`
}

type SpecDistributionModulesAuth_1 struct {
	// Dex corresponds to the JSON schema field "dex".
	Dex *SpecDistributionModulesAuthDex_1 `json:"dex,omitempty" yaml:"dex,omitempty"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *SpecDistributionModulesAuthOverrides_1 `json:"overrides,omitempty" yaml:"overrides,omitempty"`

	// Pomerium corresponds to the JSON schema field "pomerium".
	Pomerium *SpecDistributionModulesAuthPomerium_1 `json:"pomerium,omitempty" yaml:"pomerium,omitempty"`

	// Provider corresponds to the JSON schema field "provider".
	Provider *SpecDistributionModulesAuthProvider_1 `json:"provider,omitempty" yaml:"provider,omitempty"`
}

type SpecDistributionModulesAwsClusterAutoScaler struct {
	// IamRoleArn corresponds to the JSON schema field "iamRoleArn".
	IamRoleArn TypesAwsArn `json:"iamRoleArn" yaml:"iamRoleArn"`

	// NodeGroupAutoDiscovery corresponds to the JSON schema field
	// "nodeGroupAutoDiscovery".
	NodeGroupAutoDiscovery string `json:"nodeGroupAutoDiscovery" yaml:"nodeGroupAutoDiscovery"`
}

type SpecDistributionModulesAws_1 struct {
	// ClusterAutoscaler corresponds to the JSON schema field "clusterAutoscaler".
	ClusterAutoscaler *SpecDistributionModulesAwsClusterAutoScaler `json:"clusterAutoscaler,omitempty" yaml:"clusterAutoscaler,omitempty"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty"`
}

type SpecDistributionModulesDrVeleroEks_1 struct {
	// Bucket corresponds to the JSON schema field "bucket".
	Bucket *string `json:"bucket,omitempty" yaml:"bucket,omitempty"`

	// IamRoleArn corresponds to the JSON schema field "iamRoleArn".
	IamRoleArn *TypesAwsArn `json:"iamRoleArn,omitempty" yaml:"iamRoleArn,omitempty"`

	// Region corresponds to the JSON schema field "region".
	Region *TypesAwsRegion `json:"region,omitempty" yaml:"region,omitempty"`
}

type SpecDistributionModulesDrVelero_1 struct {
	// Eks corresponds to the JSON schema field "eks".
	Eks *SpecDistributionModulesDrVeleroEks_1 `json:"eks,omitempty" yaml:"eks,omitempty"`
}

type SpecDistributionModulesDr_1 struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty"`

	// Velero corresponds to the JSON schema field "velero".
	Velero *SpecDistributionModulesDrVelero_1 `json:"velero,omitempty" yaml:"velero,omitempty"`
}

type SpecDistributionModulesIngressCERTManager struct {
	// ClusterIssuer corresponds to the JSON schema field "clusterIssuer".
	ClusterIssuer SpecDistributionModulesIngressClusterIssuer `json:"clusterIssuer" yaml:"clusterIssuer"`
}

type SpecDistributionModulesIngressClusterIssuer struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name"`

	// Route53 corresponds to the JSON schema field "route53".
	Route53 *SpecDistributionModulesIngressClusterIssuerRoute53_1 `json:"route53,omitempty" yaml:"route53,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type SpecDistributionModulesIngressClusterIssuerType `json:"type" yaml:"type"`
}

type SpecDistributionModulesIngressClusterIssuerRoute53_1 struct {
	// HostedZoneId corresponds to the JSON schema field "hostedZoneId".
	HostedZoneId string `json:"hostedZoneId" yaml:"hostedZoneId"`

	// IamRoleArn corresponds to the JSON schema field "iamRoleArn".
	IamRoleArn TypesAwsArn `json:"iamRoleArn" yaml:"iamRoleArn"`

	// Region corresponds to the JSON schema field "region".
	Region TypesAwsRegion_1 `json:"region" yaml:"region"`
}

type SpecDistributionModulesIngressClusterIssuerType string

const SpecDistributionModulesIngressClusterIssuerTypeDns01 SpecDistributionModulesIngressClusterIssuerType = "dns01"
const SpecDistributionModulesIngressClusterIssuerTypeHttp01 SpecDistributionModulesIngressClusterIssuerType = "http01"

type SpecDistributionModulesIngressDNS struct {
	// Private corresponds to the JSON schema field "private".
	Private SpecDistributionModulesIngressDNSPrivate_1 `json:"private" yaml:"private"`

	// Public corresponds to the JSON schema field "public".
	Public SpecDistributionModulesIngressDNSPublic_1 `json:"public" yaml:"public"`
}

type SpecDistributionModulesIngressDNSPrivate_1 struct {
	// Enabled corresponds to the JSON schema field "enabled".
	Enabled bool `json:"enabled" yaml:"enabled"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name"`

	// VpcId corresponds to the JSON schema field "vpcId".
	VpcId string `json:"vpcId" yaml:"vpcId"`
}

type SpecDistributionModulesIngressDNSPublic_1 struct {
	// Create corresponds to the JSON schema field "create".
	Create bool `json:"create" yaml:"create"`

	// Enabled corresponds to the JSON schema field "enabled".
	Enabled bool `json:"enabled" yaml:"enabled"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name"`
}

type SpecDistributionModulesIngressNginxTLS struct {
	// Provider corresponds to the JSON schema field "provider".
	Provider SpecDistributionModulesIngressNginxTLSProvider `json:"provider" yaml:"provider"`

	// Secret corresponds to the JSON schema field "secret".
	Secret SpecDistributionModulesIngressNginxTLSSecret_1 `json:"secret" yaml:"secret"`
}

type SpecDistributionModulesIngressNginxTLSProvider string

const SpecDistributionModulesIngressNginxTLSProviderCertManager SpecDistributionModulesIngressNginxTLSProvider = "certManager"
const SpecDistributionModulesIngressNginxTLSProviderNone SpecDistributionModulesIngressNginxTLSProvider = "none"
const SpecDistributionModulesIngressNginxTLSProviderSecret SpecDistributionModulesIngressNginxTLSProvider = "secret"

type SpecDistributionModulesIngressNginxTLSSecret_1 struct {
	// Ca corresponds to the JSON schema field "ca".
	Ca string `json:"ca" yaml:"ca"`

	// Cert corresponds to the JSON schema field "cert".
	Cert string `json:"cert" yaml:"cert"`

	// Key corresponds to the JSON schema field "key".
	Key string `json:"key" yaml:"key"`
}

type SpecDistributionModulesIngressNginxType string

const SpecDistributionModulesIngressNginxTypeDual SpecDistributionModulesIngressNginxType = "dual"
const SpecDistributionModulesIngressNginxTypeSingle SpecDistributionModulesIngressNginxType = "single"

type SpecDistributionModulesIngressNginx_1 struct {
	// Tls corresponds to the JSON schema field "tls".
	Tls SpecDistributionModulesIngressNginxTLS `json:"tls" yaml:"tls"`

	// Type corresponds to the JSON schema field "type".
	Type SpecDistributionModulesIngressNginxType `json:"type" yaml:"type"`
}

type SpecDistributionModulesIngressOverridesIngresses struct {
	// Forecastle corresponds to the JSON schema field "forecastle".
	Forecastle *TypesFuryModuleOverridesIngresses_1 `json:"forecastle,omitempty" yaml:"forecastle,omitempty"`
}

type SpecDistributionModulesIngress_1 struct {
	// BaseDomain corresponds to the JSON schema field "baseDomain".
	BaseDomain string `json:"baseDomain" yaml:"baseDomain"`

	// CertManager corresponds to the JSON schema field "certManager".
	CertManager SpecDistributionModulesIngressCERTManager `json:"certManager" yaml:"certManager"`

	// Dns corresponds to the JSON schema field "dns".
	Dns SpecDistributionModulesIngressDNS `json:"dns" yaml:"dns"`

	// Nginx corresponds to the JSON schema field "nginx".
	Nginx SpecDistributionModulesIngressNginx_1 `json:"nginx" yaml:"nginx"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides TypesFuryModuleOverrides `json:"overrides" yaml:"overrides"`
}

type SpecDistributionModulesLoggingOpensearchType string

const SpecDistributionModulesLoggingOpensearchTypeSingle SpecDistributionModulesLoggingOpensearchType = "single"
const SpecDistributionModulesLoggingOpensearchTypeTriple SpecDistributionModulesLoggingOpensearchType = "triple"

type SpecDistributionModulesLoggingOpensearch_1 struct {
	// Resources corresponds to the JSON schema field "resources".
	Resources *TypesKubeResources `json:"resources,omitempty" yaml:"resources,omitempty"`

	// StorageRequest corresponds to the JSON schema field "storage_request".
	StorageRequest *string `json:"storage_request,omitempty" yaml:"storage_request,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type SpecDistributionModulesLoggingOpensearchType `json:"type" yaml:"type"`
}

type SpecDistributionModulesLogging_1 struct {
	// Opensearch corresponds to the JSON schema field "opensearch".
	Opensearch *SpecDistributionModulesLoggingOpensearch_1 `json:"opensearch,omitempty" yaml:"opensearch,omitempty"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty"`
}

type SpecDistributionModulesMonitoringPrometheus_1 struct {
	// Resources corresponds to the JSON schema field "resources".
	Resources *TypesKubeResources `json:"resources,omitempty" yaml:"resources,omitempty"`
}

type SpecDistributionModulesMonitoring_1 struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty"`

	// Prometheus corresponds to the JSON schema field "prometheus".
	Prometheus *SpecDistributionModulesMonitoringPrometheus_1 `json:"prometheus,omitempty" yaml:"prometheus,omitempty"`
}

type SpecDistributionModulesPolicyGatekeeper_1 struct {
	// AdditionalExcludedNamespaces corresponds to the JSON schema field
	// "additionalExcludedNamespaces".
	AdditionalExcludedNamespaces []string `json:"additionalExcludedNamespaces,omitempty" yaml:"additionalExcludedNamespaces,omitempty"`
}

type SpecDistributionModulesPolicy_1 struct {
	// Gatekeeper corresponds to the JSON schema field "gatekeeper".
	Gatekeeper *SpecDistributionModulesPolicyGatekeeper_1 `json:"gatekeeper,omitempty" yaml:"gatekeeper,omitempty"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty"`
}

type SpecDistributionModules_1 struct {
	// Auth corresponds to the JSON schema field "auth".
	Auth SpecDistributionModulesAuth_1 `json:"auth" yaml:"auth"`

	// Aws corresponds to the JSON schema field "aws".
	Aws *SpecDistributionModulesAws_1 `json:"aws,omitempty" yaml:"aws,omitempty"`

	// Dr corresponds to the JSON schema field "dr".
	Dr SpecDistributionModulesDr_1 `json:"dr" yaml:"dr"`

	// Ingress corresponds to the JSON schema field "ingress".
	Ingress SpecDistributionModulesIngress_1 `json:"ingress" yaml:"ingress"`

	// Logging corresponds to the JSON schema field "logging".
	Logging SpecDistributionModulesLogging_1 `json:"logging" yaml:"logging"`

	// Monitoring corresponds to the JSON schema field "monitoring".
	Monitoring SpecDistributionModulesMonitoring_1 `json:"monitoring" yaml:"monitoring"`

	// Policy corresponds to the JSON schema field "policy".
	Policy SpecDistributionModulesPolicy_1 `json:"policy" yaml:"policy"`
}

type SpecDistribution_1 struct {
	// Common corresponds to the JSON schema field "common".
	Common SpecDistributionCommon_1 `json:"common" yaml:"common"`

	// Modules corresponds to the JSON schema field "modules".
	Modules SpecDistributionModules_1 `json:"modules" yaml:"modules"`
}

type SpecInfrastructureVpcNetworkSubnetsCidrs_1 struct {
	// Private corresponds to the JSON schema field "private".
	Private []TypesCidr `json:"private" yaml:"private"`

	// Public corresponds to the JSON schema field "public".
	Public []TypesCidr `json:"public" yaml:"public"`
}

type SpecInfrastructureVpcNetwork_1 struct {
	// Cidr corresponds to the JSON schema field "cidr".
	Cidr TypesCidr `json:"cidr" yaml:"cidr"`

	// SubnetsCidrs corresponds to the JSON schema field "subnetsCidrs".
	SubnetsCidrs SpecInfrastructureVpcNetworkSubnetsCidrs_1 `json:"subnetsCidrs" yaml:"subnetsCidrs"`
}

type SpecInfrastructureVpcVpnSsh_1 struct {
	// AllowedFromCidrs corresponds to the JSON schema field "allowedFromCidrs".
	AllowedFromCidrs []TypesCidr `json:"allowedFromCidrs" yaml:"allowedFromCidrs"`

	// GithubUsersName corresponds to the JSON schema field "githubUsersName".
	GithubUsersName []string `json:"githubUsersName" yaml:"githubUsersName"`

	// PublicKeys corresponds to the JSON schema field "publicKeys".
	PublicKeys []interface{} `json:"publicKeys" yaml:"publicKeys"`
}

type SpecInfrastructureVpcVpn_1 struct {
	// DhParamsBits corresponds to the JSON schema field "dhParamsBits".
	DhParamsBits int `json:"dhParamsBits" yaml:"dhParamsBits"`

	// DiskSize corresponds to the JSON schema field "diskSize".
	DiskSize int `json:"diskSize" yaml:"diskSize"`

	// InstanceType corresponds to the JSON schema field "instanceType".
	InstanceType string `json:"instanceType" yaml:"instanceType"`

	// Instances corresponds to the JSON schema field "instances".
	Instances int `json:"instances" yaml:"instances"`

	// OperatorName corresponds to the JSON schema field "operatorName".
	OperatorName string `json:"operatorName" yaml:"operatorName"`

	// Port corresponds to the JSON schema field "port".
	Port TypesTcpPort `json:"port" yaml:"port"`

	// Ssh corresponds to the JSON schema field "ssh".
	Ssh SpecInfrastructureVpcVpnSsh_1 `json:"ssh" yaml:"ssh"`

	// VpnClientsSubnetCidr corresponds to the JSON schema field
	// "vpnClientsSubnetCidr".
	VpnClientsSubnetCidr TypesCidr `json:"vpnClientsSubnetCidr" yaml:"vpnClientsSubnetCidr"`
}

type SpecInfrastructureVpc_1 struct {
	// Network corresponds to the JSON schema field "network".
	Network SpecInfrastructureVpcNetwork_1 `json:"network" yaml:"network"`

	// Vpn corresponds to the JSON schema field "vpn".
	Vpn *SpecInfrastructureVpcVpn_1 `json:"vpn,omitempty" yaml:"vpn,omitempty"`
}

type SpecInfrastructure_1 struct {
	// Vpc corresponds to the JSON schema field "vpc".
	Vpc *SpecInfrastructureVpc_1 `json:"vpc,omitempty" yaml:"vpc,omitempty"`
}

type SpecKubernetes map[string]interface{}

type SpecKubernetesAPIServerEndpointAccess struct {
	// AllowedCidrs corresponds to the JSON schema field "allowedCidrs".
	AllowedCidrs []TypesCidr `json:"allowedCidrs" yaml:"allowedCidrs"`

	// Type corresponds to the JSON schema field "type".
	Type SpecKubernetesAPIServerEndpointAccessType `json:"type" yaml:"type"`
}

type SpecKubernetesAPIServerEndpointAccessType string

const SpecKubernetesAPIServerEndpointAccessTypePrivate SpecKubernetesAPIServerEndpointAccessType = "private"
const SpecKubernetesAPIServerEndpointAccessTypePublic SpecKubernetesAPIServerEndpointAccessType = "public"
const SpecKubernetesAPIServerEndpointAccessTypePublicAndPrivate SpecKubernetesAPIServerEndpointAccessType = "public_and_private"

type SpecKubernetesAwsAuthRole struct {
	// Groups corresponds to the JSON schema field "groups".
	Groups []string `json:"groups" yaml:"groups"`

	// Rolearn corresponds to the JSON schema field "rolearn".
	Rolearn TypesAwsArn `json:"rolearn" yaml:"rolearn"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username" yaml:"username"`
}

type SpecKubernetesAwsAuthUser struct {
	// Groups corresponds to the JSON schema field "groups".
	Groups []string `json:"groups" yaml:"groups"`

	// Userarn corresponds to the JSON schema field "userarn".
	Userarn TypesAwsArn `json:"userarn" yaml:"userarn"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username" yaml:"username"`
}

type SpecKubernetesAwsAuth_1 struct {
	// AdditionalAccounts corresponds to the JSON schema field "additionalAccounts".
	AdditionalAccounts []string `json:"additionalAccounts" yaml:"additionalAccounts"`

	// Roles corresponds to the JSON schema field "roles".
	Roles []SpecKubernetesAwsAuthRole `json:"roles" yaml:"roles"`

	// Users corresponds to the JSON schema field "users".
	Users []SpecKubernetesAwsAuthUser `json:"users" yaml:"users"`
}

type SpecKubernetesNodePool struct {
	// AdditionalFirewallRules corresponds to the JSON schema field
	// "additionalFirewallRules".
	AdditionalFirewallRules []SpecKubernetesNodePoolAdditionalFirewallRule `json:"additionalFirewallRules" yaml:"additionalFirewallRules"`

	// Ami corresponds to the JSON schema field "ami".
	Ami SpecKubernetesNodePoolAmi_1 `json:"ami" yaml:"ami"`

	// AttachedTargetGroups corresponds to the JSON schema field
	// "attachedTargetGroups".
	AttachedTargetGroups []TypesAwsArn `json:"attachedTargetGroups" yaml:"attachedTargetGroups"`

	// Instance corresponds to the JSON schema field "instance".
	Instance SpecKubernetesNodePoolInstance_1 `json:"instance" yaml:"instance"`

	// Labels corresponds to the JSON schema field "labels".
	Labels TypesKubeLabels `json:"labels" yaml:"labels"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name"`

	// Size corresponds to the JSON schema field "size".
	Size SpecKubernetesNodePoolSize_1 `json:"size" yaml:"size"`

	// Tags corresponds to the JSON schema field "tags".
	Tags TypesAwsTags `json:"tags" yaml:"tags"`

	// Taints corresponds to the JSON schema field "taints".
	Taints TypesKubeTaints `json:"taints" yaml:"taints"`
}

type SpecKubernetesNodePoolAdditionalFirewallRule struct {
	// CidrBlocks corresponds to the JSON schema field "cidrBlocks".
	CidrBlocks []TypesCidr `json:"cidrBlocks" yaml:"cidrBlocks"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name"`

	// Ports corresponds to the JSON schema field "ports".
	Ports SpecKubernetesNodePoolAdditionalFirewallRulePorts_1 `json:"ports" yaml:"ports"`

	// Protocol corresponds to the JSON schema field "protocol".
	Protocol TypesAwsIpProtocol `json:"protocol" yaml:"protocol"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type"`
}

type SpecKubernetesNodePoolAdditionalFirewallRulePorts_1 struct {
	// From corresponds to the JSON schema field "from".
	From TypesTcpPort `json:"from" yaml:"from"`

	// To corresponds to the JSON schema field "to".
	To TypesTcpPort `json:"to" yaml:"to"`
}

type SpecKubernetesNodePoolAmi_1 struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id"`

	// Owner corresponds to the JSON schema field "owner".
	Owner string `json:"owner" yaml:"owner"`
}

type SpecKubernetesNodePoolInstance_1 struct {
	// Spot corresponds to the JSON schema field "spot".
	Spot bool `json:"spot" yaml:"spot"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type"`

	// VolumeSize corresponds to the JSON schema field "volumeSize".
	VolumeSize int `json:"volumeSize" yaml:"volumeSize"`
}

type SpecKubernetesNodePoolSize_1 struct {
	// Max corresponds to the JSON schema field "max".
	Max int `json:"max" yaml:"max"`

	// Min corresponds to the JSON schema field "min".
	Min int `json:"min" yaml:"min"`
}

type SpecKubernetes_1 struct {
	// ApiServerEndpointAccess corresponds to the JSON schema field
	// "apiServerEndpointAccess".
	ApiServerEndpointAccess SpecKubernetesAPIServerEndpointAccess `json:"apiServerEndpointAccess" yaml:"apiServerEndpointAccess"`

	// AwsAuth corresponds to the JSON schema field "awsAuth".
	AwsAuth SpecKubernetesAwsAuth_1 `json:"awsAuth" yaml:"awsAuth"`

	// NodeAllowedSshPublicKey corresponds to the JSON schema field
	// "nodeAllowedSshPublicKey".
	NodeAllowedSshPublicKey interface{} `json:"nodeAllowedSshPublicKey" yaml:"nodeAllowedSshPublicKey"`

	// NodePools corresponds to the JSON schema field "nodePools".
	NodePools []SpecKubernetesNodePool `json:"nodePools" yaml:"nodePools"`

	// SubnetIds corresponds to the JSON schema field "subnetIds".
	SubnetIds []TypesAwsSubnetId `json:"subnetIds" yaml:"subnetIds"`

	// VpcId corresponds to the JSON schema field "vpcId".
	VpcId TypesAwsVpcId `json:"vpcId" yaml:"vpcId"`
}

type SpecToolsConfigurationTerraformStateS3_1 struct {
	// BucketName corresponds to the JSON schema field "bucketName".
	BucketName string `json:"bucketName" yaml:"bucketName"`

	// KeyPrefix corresponds to the JSON schema field "keyPrefix".
	KeyPrefix string `json:"keyPrefix" yaml:"keyPrefix"`

	// Region corresponds to the JSON schema field "region".
	Region TypesAwsRegion_2 `json:"region" yaml:"region"`
}

type SpecToolsConfigurationTerraformState_1 struct {
	// S3 corresponds to the JSON schema field "s3".
	S3 SpecToolsConfigurationTerraformStateS3_1 `json:"s3" yaml:"s3"`
}

type SpecToolsConfigurationTerraform_1 struct {
	// State corresponds to the JSON schema field "state".
	State SpecToolsConfigurationTerraformState_1 `json:"state" yaml:"state"`
}

type SpecToolsConfiguration_1 struct {
	// Terraform corresponds to the JSON schema field "terraform".
	Terraform SpecToolsConfigurationTerraform_1 `json:"terraform" yaml:"terraform"`
}

type TypesAwsArn string

type TypesAwsIpProtocol string

const TypesAwsIpProtocolA1 TypesAwsIpProtocol = "-1"
const TypesAwsIpProtocolIcmp TypesAwsIpProtocol = "icmp"
const TypesAwsIpProtocolIcmpv6 TypesAwsIpProtocol = "icmpv6"
const TypesAwsIpProtocolTcp TypesAwsIpProtocol = "tcp"
const TypesAwsIpProtocolUdp TypesAwsIpProtocol = "udp"

type TypesAwsIpProtocol_1 string

const TypesAwsIpProtocol_1_A1 TypesAwsIpProtocol_1 = "-1"
const TypesAwsIpProtocol_1_Icmp TypesAwsIpProtocol_1 = "icmp"
const TypesAwsIpProtocol_1_Icmpv6 TypesAwsIpProtocol_1 = "icmpv6"
const TypesAwsIpProtocol_1_Tcp TypesAwsIpProtocol_1 = "tcp"
const TypesAwsIpProtocol_1_Udp TypesAwsIpProtocol_1 = "udp"

type TypesAwsRegion string

const TypesAwsRegionAfSouth1 TypesAwsRegion = "af-south-1"
const TypesAwsRegionApEast1 TypesAwsRegion = "ap-east-1"
const TypesAwsRegionApNortheast1 TypesAwsRegion = "ap-northeast-1"
const TypesAwsRegionApNortheast2 TypesAwsRegion = "ap-northeast-2"
const TypesAwsRegionApNortheast3 TypesAwsRegion = "ap-northeast-3"
const TypesAwsRegionApSouth1 TypesAwsRegion = "ap-south-1"
const TypesAwsRegionApSoutheast1 TypesAwsRegion = "ap-southeast-1"
const TypesAwsRegionApSoutheast2 TypesAwsRegion = "ap-southeast-2"
const TypesAwsRegionApSoutheast3 TypesAwsRegion = "ap-southeast-3"
const TypesAwsRegionCaCentral1 TypesAwsRegion = "ca-central-1"
const TypesAwsRegionEuCentral1 TypesAwsRegion = "eu-central-1"
const TypesAwsRegionEuNorth1 TypesAwsRegion = "eu-north-1"
const TypesAwsRegionEuSouth1 TypesAwsRegion = "eu-south-1"
const TypesAwsRegionEuWest1 TypesAwsRegion = "eu-west-1"
const TypesAwsRegionEuWest2 TypesAwsRegion = "eu-west-2"
const TypesAwsRegionEuWest3 TypesAwsRegion = "eu-west-3"
const TypesAwsRegionMeCentral1 TypesAwsRegion = "me-central-1"
const TypesAwsRegionMeSouth1 TypesAwsRegion = "me-south-1"
const TypesAwsRegionSaEast1 TypesAwsRegion = "sa-east-1"
const TypesAwsRegionUsEast1 TypesAwsRegion = "us-east-1"
const TypesAwsRegionUsEast2 TypesAwsRegion = "us-east-2"
const TypesAwsRegionUsWest1 TypesAwsRegion = "us-west-1"
const TypesAwsRegionUsWest2 TypesAwsRegion = "us-west-2"

type TypesAwsRegion_1 string

const TypesAwsRegion_1_AfSouth1 TypesAwsRegion_1 = "af-south-1"
const TypesAwsRegion_1_ApEast1 TypesAwsRegion_1 = "ap-east-1"
const TypesAwsRegion_1_ApNortheast1 TypesAwsRegion_1 = "ap-northeast-1"
const TypesAwsRegion_1_ApNortheast2 TypesAwsRegion_1 = "ap-northeast-2"
const TypesAwsRegion_1_ApNortheast3 TypesAwsRegion_1 = "ap-northeast-3"
const TypesAwsRegion_1_ApSouth1 TypesAwsRegion_1 = "ap-south-1"
const TypesAwsRegion_1_ApSoutheast1 TypesAwsRegion_1 = "ap-southeast-1"
const TypesAwsRegion_1_ApSoutheast2 TypesAwsRegion_1 = "ap-southeast-2"
const TypesAwsRegion_1_ApSoutheast3 TypesAwsRegion_1 = "ap-southeast-3"
const TypesAwsRegion_1_CaCentral1 TypesAwsRegion_1 = "ca-central-1"
const TypesAwsRegion_1_EuCentral1 TypesAwsRegion_1 = "eu-central-1"
const TypesAwsRegion_1_EuNorth1 TypesAwsRegion_1 = "eu-north-1"
const TypesAwsRegion_1_EuSouth1 TypesAwsRegion_1 = "eu-south-1"
const TypesAwsRegion_1_EuWest1 TypesAwsRegion_1 = "eu-west-1"
const TypesAwsRegion_1_EuWest2 TypesAwsRegion_1 = "eu-west-2"
const TypesAwsRegion_1_EuWest3 TypesAwsRegion_1 = "eu-west-3"
const TypesAwsRegion_1_MeCentral1 TypesAwsRegion_1 = "me-central-1"
const TypesAwsRegion_1_MeSouth1 TypesAwsRegion_1 = "me-south-1"
const TypesAwsRegion_1_SaEast1 TypesAwsRegion_1 = "sa-east-1"
const TypesAwsRegion_1_UsEast1 TypesAwsRegion_1 = "us-east-1"
const TypesAwsRegion_1_UsEast2 TypesAwsRegion_1 = "us-east-2"
const TypesAwsRegion_1_UsWest1 TypesAwsRegion_1 = "us-west-1"
const TypesAwsRegion_1_UsWest2 TypesAwsRegion_1 = "us-west-2"

type TypesAwsRegion_2 string

const TypesAwsRegion_2_AfSouth1 TypesAwsRegion_2 = "af-south-1"
const TypesAwsRegion_2_ApEast1 TypesAwsRegion_2 = "ap-east-1"
const TypesAwsRegion_2_ApNortheast1 TypesAwsRegion_2 = "ap-northeast-1"
const TypesAwsRegion_2_ApNortheast2 TypesAwsRegion_2 = "ap-northeast-2"
const TypesAwsRegion_2_ApNortheast3 TypesAwsRegion_2 = "ap-northeast-3"
const TypesAwsRegion_2_ApSouth1 TypesAwsRegion_2 = "ap-south-1"
const TypesAwsRegion_2_ApSoutheast1 TypesAwsRegion_2 = "ap-southeast-1"
const TypesAwsRegion_2_ApSoutheast2 TypesAwsRegion_2 = "ap-southeast-2"
const TypesAwsRegion_2_ApSoutheast3 TypesAwsRegion_2 = "ap-southeast-3"
const TypesAwsRegion_2_CaCentral1 TypesAwsRegion_2 = "ca-central-1"
const TypesAwsRegion_2_EuCentral1 TypesAwsRegion_2 = "eu-central-1"
const TypesAwsRegion_2_EuNorth1 TypesAwsRegion_2 = "eu-north-1"
const TypesAwsRegion_2_EuSouth1 TypesAwsRegion_2 = "eu-south-1"
const TypesAwsRegion_2_EuWest1 TypesAwsRegion_2 = "eu-west-1"
const TypesAwsRegion_2_EuWest2 TypesAwsRegion_2 = "eu-west-2"
const TypesAwsRegion_2_EuWest3 TypesAwsRegion_2 = "eu-west-3"
const TypesAwsRegion_2_MeCentral1 TypesAwsRegion_2 = "me-central-1"
const TypesAwsRegion_2_MeSouth1 TypesAwsRegion_2 = "me-south-1"
const TypesAwsRegion_2_SaEast1 TypesAwsRegion_2 = "sa-east-1"
const TypesAwsRegion_2_UsEast1 TypesAwsRegion_2 = "us-east-1"
const TypesAwsRegion_2_UsEast2 TypesAwsRegion_2 = "us-east-2"
const TypesAwsRegion_2_UsWest1 TypesAwsRegion_2 = "us-west-1"
const TypesAwsRegion_2_UsWest2 TypesAwsRegion_2 = "us-west-2"

type TypesAwsRegion_3 string

const TypesAwsRegion_3_AfSouth1 TypesAwsRegion_3 = "af-south-1"
const TypesAwsRegion_3_ApEast1 TypesAwsRegion_3 = "ap-east-1"
const TypesAwsRegion_3_ApNortheast1 TypesAwsRegion_3 = "ap-northeast-1"
const TypesAwsRegion_3_ApNortheast2 TypesAwsRegion_3 = "ap-northeast-2"
const TypesAwsRegion_3_ApNortheast3 TypesAwsRegion_3 = "ap-northeast-3"
const TypesAwsRegion_3_ApSouth1 TypesAwsRegion_3 = "ap-south-1"
const TypesAwsRegion_3_ApSoutheast1 TypesAwsRegion_3 = "ap-southeast-1"
const TypesAwsRegion_3_ApSoutheast2 TypesAwsRegion_3 = "ap-southeast-2"
const TypesAwsRegion_3_ApSoutheast3 TypesAwsRegion_3 = "ap-southeast-3"
const TypesAwsRegion_3_CaCentral1 TypesAwsRegion_3 = "ca-central-1"
const TypesAwsRegion_3_EuCentral1 TypesAwsRegion_3 = "eu-central-1"
const TypesAwsRegion_3_EuNorth1 TypesAwsRegion_3 = "eu-north-1"
const TypesAwsRegion_3_EuSouth1 TypesAwsRegion_3 = "eu-south-1"
const TypesAwsRegion_3_EuWest1 TypesAwsRegion_3 = "eu-west-1"
const TypesAwsRegion_3_EuWest2 TypesAwsRegion_3 = "eu-west-2"
const TypesAwsRegion_3_EuWest3 TypesAwsRegion_3 = "eu-west-3"
const TypesAwsRegion_3_MeCentral1 TypesAwsRegion_3 = "me-central-1"
const TypesAwsRegion_3_MeSouth1 TypesAwsRegion_3 = "me-south-1"
const TypesAwsRegion_3_SaEast1 TypesAwsRegion_3 = "sa-east-1"
const TypesAwsRegion_3_UsEast1 TypesAwsRegion_3 = "us-east-1"
const TypesAwsRegion_3_UsEast2 TypesAwsRegion_3 = "us-east-2"
const TypesAwsRegion_3_UsWest1 TypesAwsRegion_3 = "us-west-1"
const TypesAwsRegion_3_UsWest2 TypesAwsRegion_3 = "us-west-2"

type TypesAwsSubnetId string

type TypesAwsTags map[string]string

type TypesAwsVpcId string

type TypesCidr string

type TypesEnvRef string

type TypesFileRef string

type TypesFuryModuleOverrides struct {
	// Ingresses corresponds to the JSON schema field "ingresses".
	Ingresses TypesFuryModuleOverridesIngresses `json:"ingresses,omitempty" yaml:"ingresses,omitempty"`

	// NodeSelector corresponds to the JSON schema field "nodeSelector".
	NodeSelector TypesKubeNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`

	// Tolerations corresponds to the JSON schema field "tolerations".
	Tolerations []TypesKubeToleration `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
}

type TypesFuryModuleOverridesIngresses map[string]TypesFuryModuleOverridesIngresses_1

type TypesFuryModuleOverridesIngresses_1 struct {
	// DisableAuth corresponds to the JSON schema field "disableAuth".
	DisableAuth bool `json:"disableAuth" yaml:"disableAuth"`

	// Host corresponds to the JSON schema field "host".
	Host string `json:"host" yaml:"host"`

	// IngressClass corresponds to the JSON schema field "ingressClass".
	IngressClass string `json:"ingressClass" yaml:"ingressClass"`
}

type TypesIpAddress string

type TypesKubeLabels map[string]string

type TypesKubeNodeSelector map[string]string

type TypesKubeResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *TypesKubeResourcesLimits `json:"limits,omitempty" yaml:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *TypesKubeResourcesRequests `json:"requests,omitempty" yaml:"requests,omitempty"`
}

type TypesKubeResourcesLimits struct {
	// Cpu corresponds to the JSON schema field "cpu".
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`

	// Memory corresponds to the JSON schema field "memory".
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`
}

type TypesKubeResourcesRequests struct {
	// Cpu corresponds to the JSON schema field "cpu".
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`

	// Memory corresponds to the JSON schema field "memory".
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`
}

type TypesKubeTaints []string

type TypesKubeToleration struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect TypesKubeTolerationEffect `json:"effect" yaml:"effect"`

	// Key corresponds to the JSON schema field "key".
	Key string `json:"key" yaml:"key"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value"`
}

type TypesKubeTolerationEffect string

const TypesKubeTolerationEffectNoExecute TypesKubeTolerationEffect = "NoExecute"
const TypesKubeTolerationEffectNoSchedule TypesKubeTolerationEffect = "NoSchedule"
const TypesKubeTolerationEffectPreferNoSchedule TypesKubeTolerationEffect = "PreferNoSchedule"

type TypesSemVer string

type TypesSshPubKey string

type TypesTcpPort int

type TypesUri string

var enumValues_EksclusterKfdV1Alpha2JsonKind = []interface{}{
	"EKSCluster",
}
var enumValues_SpecDistributionModulesAuthProviderType = []interface{}{
	"none",
	"basicAuth",
	"sso",
}
var enumValues_SpecDistributionModulesIngressClusterIssuerType = []interface{}{
	"dns01",
	"http01",
}
var enumValues_SpecDistributionModulesIngressNginxTLSProvider = []interface{}{
	"certManager",
	"secret",
	"none",
}
var enumValues_SpecDistributionModulesIngressNginxType = []interface{}{
	"single",
	"dual",
}
var enumValues_SpecDistributionModulesLoggingOpensearchType = []interface{}{
	"single",
	"triple",
}
var enumValues_SpecKubernetesAPIServerEndpointAccessType = []interface{}{
	"public",
	"private",
	"public_and_private",
}
var enumValues_TypesAwsIpProtocol = []interface{}{
	"tcp",
	"udp",
	"icmp",
	"icmpv6",
	"-1",
}
var enumValues_TypesAwsIpProtocol_1 = []interface{}{
	"tcp",
	"udp",
	"icmp",
	"icmpv6",
	"-1",
}
var enumValues_TypesAwsRegion = []interface{}{
	"af-south-1",
	"ap-east-1",
	"ap-northeast-1",
	"ap-northeast-2",
	"ap-northeast-3",
	"ap-south-1",
	"ap-southeast-1",
	"ap-southeast-2",
	"ap-southeast-3",
	"ca-central-1",
	"eu-central-1",
	"eu-north-1",
	"eu-south-1",
	"eu-west-1",
	"eu-west-2",
	"eu-west-3",
	"me-central-1",
	"me-south-1",
	"sa-east-1",
	"us-east-1",
	"us-east-2",
	"us-west-1",
	"us-west-2",
}
var enumValues_TypesAwsRegion_1 = []interface{}{
	"af-south-1",
	"ap-east-1",
	"ap-northeast-1",
	"ap-northeast-2",
	"ap-northeast-3",
	"ap-south-1",
	"ap-southeast-1",
	"ap-southeast-2",
	"ap-southeast-3",
	"ca-central-1",
	"eu-central-1",
	"eu-north-1",
	"eu-south-1",
	"eu-west-1",
	"eu-west-2",
	"eu-west-3",
	"me-central-1",
	"me-south-1",
	"sa-east-1",
	"us-east-1",
	"us-east-2",
	"us-west-1",
	"us-west-2",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesAwsIpProtocol) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesAwsIpProtocol {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesAwsIpProtocol, v)
	}
	*j = TypesAwsIpProtocol(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolAdditionalFirewallRulePorts_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["from"]; !ok || v == nil {
		return fmt.Errorf("field from in SpecKubernetesNodePoolAdditionalFirewallRulePorts_1: required")
	}
	if v, ok := raw["to"]; !ok || v == nil {
		return fmt.Errorf("field to in SpecKubernetesNodePoolAdditionalFirewallRulePorts_1: required")
	}
	type Plain SpecKubernetesNodePoolAdditionalFirewallRulePorts_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePoolAdditionalFirewallRulePorts_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolAdditionalFirewallRule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["cidrBlocks"]; !ok || v == nil {
		return fmt.Errorf("field cidrBlocks in SpecKubernetesNodePoolAdditionalFirewallRule: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecKubernetesNodePoolAdditionalFirewallRule: required")
	}
	if v, ok := raw["ports"]; !ok || v == nil {
		return fmt.Errorf("field ports in SpecKubernetesNodePoolAdditionalFirewallRule: required")
	}
	if v, ok := raw["protocol"]; !ok || v == nil {
		return fmt.Errorf("field protocol in SpecKubernetesNodePoolAdditionalFirewallRule: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecKubernetesNodePoolAdditionalFirewallRule: required")
	}
	type Plain SpecKubernetesNodePoolAdditionalFirewallRule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePoolAdditionalFirewallRule(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesAwsAuth_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["additionalAccounts"]; !ok || v == nil {
		return fmt.Errorf("field additionalAccounts in SpecKubernetesAwsAuth_1: required")
	}
	if v, ok := raw["roles"]; !ok || v == nil {
		return fmt.Errorf("field roles in SpecKubernetesAwsAuth_1: required")
	}
	if v, ok := raw["users"]; !ok || v == nil {
		return fmt.Errorf("field users in SpecKubernetesAwsAuth_1: required")
	}
	type Plain SpecKubernetesAwsAuth_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesAwsAuth_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolAmi_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in SpecKubernetesNodePoolAmi_1: required")
	}
	if v, ok := raw["owner"]; !ok || v == nil {
		return fmt.Errorf("field owner in SpecKubernetesNodePoolAmi_1: required")
	}
	type Plain SpecKubernetesNodePoolAmi_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePoolAmi_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesAwsAuthUser) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["groups"]; !ok || v == nil {
		return fmt.Errorf("field groups in SpecKubernetesAwsAuthUser: required")
	}
	if v, ok := raw["userarn"]; !ok || v == nil {
		return fmt.Errorf("field userarn in SpecKubernetesAwsAuthUser: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username in SpecKubernetesAwsAuthUser: required")
	}
	type Plain SpecKubernetesAwsAuthUser
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesAwsAuthUser(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolInstance_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["spot"]; !ok || v == nil {
		return fmt.Errorf("field spot in SpecKubernetesNodePoolInstance_1: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecKubernetesNodePoolInstance_1: required")
	}
	if v, ok := raw["volumeSize"]; !ok || v == nil {
		return fmt.Errorf("field volumeSize in SpecKubernetesNodePoolInstance_1: required")
	}
	type Plain SpecKubernetesNodePoolInstance_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePoolInstance_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesAwsAuthRole) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["groups"]; !ok || v == nil {
		return fmt.Errorf("field groups in SpecKubernetesAwsAuthRole: required")
	}
	if v, ok := raw["rolearn"]; !ok || v == nil {
		return fmt.Errorf("field rolearn in SpecKubernetesAwsAuthRole: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username in SpecKubernetesAwsAuthRole: required")
	}
	type Plain SpecKubernetesAwsAuthRole
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesAwsAuthRole(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesAPIServerEndpointAccess) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["allowedCidrs"]; !ok || v == nil {
		return fmt.Errorf("field allowedCidrs in SpecKubernetesAPIServerEndpointAccess: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecKubernetesAPIServerEndpointAccess: required")
	}
	type Plain SpecKubernetesAPIServerEndpointAccess
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesAPIServerEndpointAccess(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolSize_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["max"]; !ok || v == nil {
		return fmt.Errorf("field max in SpecKubernetesNodePoolSize_1: required")
	}
	if v, ok := raw["min"]; !ok || v == nil {
		return fmt.Errorf("field min in SpecKubernetesNodePoolSize_1: required")
	}
	type Plain SpecKubernetesNodePoolSize_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePoolSize_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesAPIServerEndpointAccessType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecKubernetesAPIServerEndpointAccessType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecKubernetesAPIServerEndpointAccessType, v)
	}
	*j = SpecKubernetesAPIServerEndpointAccessType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Spec) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["distributionVersion"]; !ok || v == nil {
		return fmt.Errorf("field distributionVersion in Spec: required")
	}
	if v, ok := raw["kubernetes"]; !ok || v == nil {
		return fmt.Errorf("field kubernetes in Spec: required")
	}
	if v, ok := raw["toolsConfiguration"]; !ok || v == nil {
		return fmt.Errorf("field toolsConfiguration in Spec: required")
	}
	type Plain Spec
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Spec(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePool) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["additionalFirewallRules"]; !ok || v == nil {
		return fmt.Errorf("field additionalFirewallRules in SpecKubernetesNodePool: required")
	}
	if v, ok := raw["ami"]; !ok || v == nil {
		return fmt.Errorf("field ami in SpecKubernetesNodePool: required")
	}
	if v, ok := raw["attachedTargetGroups"]; !ok || v == nil {
		return fmt.Errorf("field attachedTargetGroups in SpecKubernetesNodePool: required")
	}
	if v, ok := raw["instance"]; !ok || v == nil {
		return fmt.Errorf("field instance in SpecKubernetesNodePool: required")
	}
	if v, ok := raw["labels"]; !ok || v == nil {
		return fmt.Errorf("field labels in SpecKubernetesNodePool: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecKubernetesNodePool: required")
	}
	if v, ok := raw["size"]; !ok || v == nil {
		return fmt.Errorf("field size in SpecKubernetesNodePool: required")
	}
	if v, ok := raw["tags"]; !ok || v == nil {
		return fmt.Errorf("field tags in SpecKubernetesNodePool: required")
	}
	if v, ok := raw["taints"]; !ok || v == nil {
		return fmt.Errorf("field taints in SpecKubernetesNodePool: required")
	}
	type Plain SpecKubernetesNodePool
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePool(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecToolsConfiguration_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["terraform"]; !ok || v == nil {
		return fmt.Errorf("field terraform in SpecToolsConfiguration_1: required")
	}
	type Plain SpecToolsConfiguration_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecToolsConfiguration_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecToolsConfigurationTerraform_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["state"]; !ok || v == nil {
		return fmt.Errorf("field state in SpecToolsConfigurationTerraform_1: required")
	}
	type Plain SpecToolsConfigurationTerraform_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecToolsConfigurationTerraform_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecToolsConfigurationTerraformState_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["s3"]; !ok || v == nil {
		return fmt.Errorf("field s3 in SpecToolsConfigurationTerraformState_1: required")
	}
	type Plain SpecToolsConfigurationTerraformState_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecToolsConfigurationTerraformState_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetes_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["apiServerEndpointAccess"]; !ok || v == nil {
		return fmt.Errorf("field apiServerEndpointAccess in SpecKubernetes_1: required")
	}
	if v, ok := raw["awsAuth"]; !ok || v == nil {
		return fmt.Errorf("field awsAuth in SpecKubernetes_1: required")
	}
	if v, ok := raw["nodeAllowedSshPublicKey"]; !ok || v == nil {
		return fmt.Errorf("field nodeAllowedSshPublicKey in SpecKubernetes_1: required")
	}
	if v, ok := raw["nodePools"]; !ok || v == nil {
		return fmt.Errorf("field nodePools in SpecKubernetes_1: required")
	}
	if v, ok := raw["subnetIds"]; !ok || v == nil {
		return fmt.Errorf("field subnetIds in SpecKubernetes_1: required")
	}
	if v, ok := raw["vpcId"]; !ok || v == nil {
		return fmt.Errorf("field vpcId in SpecKubernetes_1: required")
	}
	type Plain SpecKubernetes_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetes_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecToolsConfigurationTerraformStateS3_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bucketName"]; !ok || v == nil {
		return fmt.Errorf("field bucketName in SpecToolsConfigurationTerraformStateS3_1: required")
	}
	if v, ok := raw["keyPrefix"]; !ok || v == nil {
		return fmt.Errorf("field keyPrefix in SpecToolsConfigurationTerraformStateS3_1: required")
	}
	if v, ok := raw["region"]; !ok || v == nil {
		return fmt.Errorf("field region in SpecToolsConfigurationTerraformStateS3_1: required")
	}
	type Plain SpecToolsConfigurationTerraformStateS3_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecToolsConfigurationTerraformStateS3_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesAwsRegion_2) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesAwsRegion_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesAwsRegion_2, v)
	}
	*j = TypesAwsRegion_2(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesAwsIpProtocol_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesAwsIpProtocol_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesAwsIpProtocol_1, v)
	}
	*j = TypesAwsIpProtocol_1(v)
	return nil
}

var enumValues_TypesAwsRegion_2 = []interface{}{
	"af-south-1",
	"ap-east-1",
	"ap-northeast-1",
	"ap-northeast-2",
	"ap-northeast-3",
	"ap-south-1",
	"ap-southeast-1",
	"ap-southeast-2",
	"ap-southeast-3",
	"ca-central-1",
	"eu-central-1",
	"eu-north-1",
	"eu-south-1",
	"eu-west-1",
	"eu-west-2",
	"eu-west-3",
	"me-central-1",
	"me-south-1",
	"sa-east-1",
	"us-east-1",
	"us-east-2",
	"us-west-1",
	"us-west-2",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureVpc_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["network"]; !ok || v == nil {
		return fmt.Errorf("field network in SpecInfrastructureVpc_1: required")
	}
	type Plain SpecInfrastructureVpc_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureVpc_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureVpcVpn_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["dhParamsBits"]; !ok || v == nil {
		return fmt.Errorf("field dhParamsBits in SpecInfrastructureVpcVpn_1: required")
	}
	if v, ok := raw["diskSize"]; !ok || v == nil {
		return fmt.Errorf("field diskSize in SpecInfrastructureVpcVpn_1: required")
	}
	if v, ok := raw["instanceType"]; !ok || v == nil {
		return fmt.Errorf("field instanceType in SpecInfrastructureVpcVpn_1: required")
	}
	if v, ok := raw["instances"]; !ok || v == nil {
		return fmt.Errorf("field instances in SpecInfrastructureVpcVpn_1: required")
	}
	if v, ok := raw["operatorName"]; !ok || v == nil {
		return fmt.Errorf("field operatorName in SpecInfrastructureVpcVpn_1: required")
	}
	if v, ok := raw["port"]; !ok || v == nil {
		return fmt.Errorf("field port in SpecInfrastructureVpcVpn_1: required")
	}
	if v, ok := raw["ssh"]; !ok || v == nil {
		return fmt.Errorf("field ssh in SpecInfrastructureVpcVpn_1: required")
	}
	if v, ok := raw["vpnClientsSubnetCidr"]; !ok || v == nil {
		return fmt.Errorf("field vpnClientsSubnetCidr in SpecInfrastructureVpcVpn_1: required")
	}
	type Plain SpecInfrastructureVpcVpn_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureVpcVpn_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureVpcVpnSsh_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["allowedFromCidrs"]; !ok || v == nil {
		return fmt.Errorf("field allowedFromCidrs in SpecInfrastructureVpcVpnSsh_1: required")
	}
	if v, ok := raw["githubUsersName"]; !ok || v == nil {
		return fmt.Errorf("field githubUsersName in SpecInfrastructureVpcVpnSsh_1: required")
	}
	if v, ok := raw["publicKeys"]; !ok || v == nil {
		return fmt.Errorf("field publicKeys in SpecInfrastructureVpcVpnSsh_1: required")
	}
	type Plain SpecInfrastructureVpcVpnSsh_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureVpcVpnSsh_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureVpcNetwork_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["cidr"]; !ok || v == nil {
		return fmt.Errorf("field cidr in SpecInfrastructureVpcNetwork_1: required")
	}
	if v, ok := raw["subnetsCidrs"]; !ok || v == nil {
		return fmt.Errorf("field subnetsCidrs in SpecInfrastructureVpcNetwork_1: required")
	}
	type Plain SpecInfrastructureVpcNetwork_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureVpcNetwork_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureVpcNetworkSubnetsCidrs_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["private"]; !ok || v == nil {
		return fmt.Errorf("field private in SpecInfrastructureVpcNetworkSubnetsCidrs_1: required")
	}
	if v, ok := raw["public"]; !ok || v == nil {
		return fmt.Errorf("field public in SpecInfrastructureVpcNetworkSubnetsCidrs_1: required")
	}
	type Plain SpecInfrastructureVpcNetworkSubnetsCidrs_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureVpcNetworkSubnetsCidrs_1(plain)
	return nil
}

var enumValues_TypesAwsRegion_3 = []interface{}{
	"af-south-1",
	"ap-east-1",
	"ap-northeast-1",
	"ap-northeast-2",
	"ap-northeast-3",
	"ap-south-1",
	"ap-southeast-1",
	"ap-southeast-2",
	"ap-southeast-3",
	"ca-central-1",
	"eu-central-1",
	"eu-north-1",
	"eu-south-1",
	"eu-west-1",
	"eu-west-2",
	"eu-west-3",
	"me-central-1",
	"me-south-1",
	"sa-east-1",
	"us-east-1",
	"us-east-2",
	"us-west-1",
	"us-west-2",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesAwsRegion_3) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesAwsRegion_3 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesAwsRegion_3, v)
	}
	*j = TypesAwsRegion_3(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistribution_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["common"]; !ok || v == nil {
		return fmt.Errorf("field common in SpecDistribution_1: required")
	}
	if v, ok := raw["modules"]; !ok || v == nil {
		return fmt.Errorf("field modules in SpecDistribution_1: required")
	}
	type Plain SpecDistribution_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistribution_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModules_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["auth"]; !ok || v == nil {
		return fmt.Errorf("field auth in SpecDistributionModules_1: required")
	}
	if v, ok := raw["dr"]; !ok || v == nil {
		return fmt.Errorf("field dr in SpecDistributionModules_1: required")
	}
	if v, ok := raw["ingress"]; !ok || v == nil {
		return fmt.Errorf("field ingress in SpecDistributionModules_1: required")
	}
	if v, ok := raw["logging"]; !ok || v == nil {
		return fmt.Errorf("field logging in SpecDistributionModules_1: required")
	}
	if v, ok := raw["monitoring"]; !ok || v == nil {
		return fmt.Errorf("field monitoring in SpecDistributionModules_1: required")
	}
	if v, ok := raw["policy"]; !ok || v == nil {
		return fmt.Errorf("field policy in SpecDistributionModules_1: required")
	}
	type Plain SpecDistributionModules_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModules_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesLoggingOpensearch_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesLoggingOpensearch_1: required")
	}
	type Plain SpecDistributionModulesLoggingOpensearch_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesLoggingOpensearch_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesLoggingOpensearchType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesLoggingOpensearchType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesLoggingOpensearchType, v)
	}
	*j = SpecDistributionModulesLoggingOpensearchType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngress_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["baseDomain"]; !ok || v == nil {
		return fmt.Errorf("field baseDomain in SpecDistributionModulesIngress_1: required")
	}
	if v, ok := raw["certManager"]; !ok || v == nil {
		return fmt.Errorf("field certManager in SpecDistributionModulesIngress_1: required")
	}
	if v, ok := raw["dns"]; !ok || v == nil {
		return fmt.Errorf("field dns in SpecDistributionModulesIngress_1: required")
	}
	if v, ok := raw["nginx"]; !ok || v == nil {
		return fmt.Errorf("field nginx in SpecDistributionModulesIngress_1: required")
	}
	if v, ok := raw["overrides"]; !ok || v == nil {
		return fmt.Errorf("field overrides in SpecDistributionModulesIngress_1: required")
	}
	type Plain SpecDistributionModulesIngress_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngress_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginx_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["tls"]; !ok || v == nil {
		return fmt.Errorf("field tls in SpecDistributionModulesIngressNginx_1: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesIngressNginx_1: required")
	}
	type Plain SpecDistributionModulesIngressNginx_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressNginx_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginxType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesIngressNginxType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesIngressNginxType, v)
	}
	*j = SpecDistributionModulesIngressNginxType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginxTLS) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["provider"]; !ok || v == nil {
		return fmt.Errorf("field provider in SpecDistributionModulesIngressNginxTLS: required")
	}
	if v, ok := raw["secret"]; !ok || v == nil {
		return fmt.Errorf("field secret in SpecDistributionModulesIngressNginxTLS: required")
	}
	type Plain SpecDistributionModulesIngressNginxTLS
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressNginxTLS(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginxTLSSecret_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ca"]; !ok || v == nil {
		return fmt.Errorf("field ca in SpecDistributionModulesIngressNginxTLSSecret_1: required")
	}
	if v, ok := raw["cert"]; !ok || v == nil {
		return fmt.Errorf("field cert in SpecDistributionModulesIngressNginxTLSSecret_1: required")
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key in SpecDistributionModulesIngressNginxTLSSecret_1: required")
	}
	type Plain SpecDistributionModulesIngressNginxTLSSecret_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressNginxTLSSecret_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginxTLSProvider) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesIngressNginxTLSProvider {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesIngressNginxTLSProvider, v)
	}
	*j = SpecDistributionModulesIngressNginxTLSProvider(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressDNS) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["private"]; !ok || v == nil {
		return fmt.Errorf("field private in SpecDistributionModulesIngressDNS: required")
	}
	if v, ok := raw["public"]; !ok || v == nil {
		return fmt.Errorf("field public in SpecDistributionModulesIngressDNS: required")
	}
	type Plain SpecDistributionModulesIngressDNS
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressDNS(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressDNSPublic_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["create"]; !ok || v == nil {
		return fmt.Errorf("field create in SpecDistributionModulesIngressDNSPublic_1: required")
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		return fmt.Errorf("field enabled in SpecDistributionModulesIngressDNSPublic_1: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecDistributionModulesIngressDNSPublic_1: required")
	}
	type Plain SpecDistributionModulesIngressDNSPublic_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressDNSPublic_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressDNSPrivate_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		return fmt.Errorf("field enabled in SpecDistributionModulesIngressDNSPrivate_1: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecDistributionModulesIngressDNSPrivate_1: required")
	}
	if v, ok := raw["vpcId"]; !ok || v == nil {
		return fmt.Errorf("field vpcId in SpecDistributionModulesIngressDNSPrivate_1: required")
	}
	type Plain SpecDistributionModulesIngressDNSPrivate_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressDNSPrivate_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressCERTManager) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["clusterIssuer"]; !ok || v == nil {
		return fmt.Errorf("field clusterIssuer in SpecDistributionModulesIngressCERTManager: required")
	}
	type Plain SpecDistributionModulesIngressCERTManager
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressCERTManager(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressClusterIssuer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecDistributionModulesIngressClusterIssuer: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesIngressClusterIssuer: required")
	}
	type Plain SpecDistributionModulesIngressClusterIssuer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressClusterIssuer(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressClusterIssuerType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesIngressClusterIssuerType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesIngressClusterIssuerType, v)
	}
	*j = SpecDistributionModulesIngressClusterIssuerType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressClusterIssuerRoute53_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["hostedZoneId"]; !ok || v == nil {
		return fmt.Errorf("field hostedZoneId in SpecDistributionModulesIngressClusterIssuerRoute53_1: required")
	}
	if v, ok := raw["iamRoleArn"]; !ok || v == nil {
		return fmt.Errorf("field iamRoleArn in SpecDistributionModulesIngressClusterIssuerRoute53_1: required")
	}
	if v, ok := raw["region"]; !ok || v == nil {
		return fmt.Errorf("field region in SpecDistributionModulesIngressClusterIssuerRoute53_1: required")
	}
	type Plain SpecDistributionModulesIngressClusterIssuerRoute53_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressClusterIssuerRoute53_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesAwsRegion_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesAwsRegion_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesAwsRegion_1, v)
	}
	*j = TypesAwsRegion_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesAwsRegion) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesAwsRegion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesAwsRegion, v)
	}
	*j = TypesAwsRegion(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesFuryModuleOverridesIngresses_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["disableAuth"]; !ok || v == nil {
		return fmt.Errorf("field disableAuth in TypesFuryModuleOverridesIngresses_1: required")
	}
	if v, ok := raw["host"]; !ok || v == nil {
		return fmt.Errorf("field host in TypesFuryModuleOverridesIngresses_1: required")
	}
	if v, ok := raw["ingressClass"]; !ok || v == nil {
		return fmt.Errorf("field ingressClass in TypesFuryModuleOverridesIngresses_1: required")
	}
	type Plain TypesFuryModuleOverridesIngresses_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TypesFuryModuleOverridesIngresses_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAwsClusterAutoScaler) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["iamRoleArn"]; !ok || v == nil {
		return fmt.Errorf("field iamRoleArn in SpecDistributionModulesAwsClusterAutoScaler: required")
	}
	if v, ok := raw["nodeGroupAutoDiscovery"]; !ok || v == nil {
		return fmt.Errorf("field nodeGroupAutoDiscovery in SpecDistributionModulesAwsClusterAutoScaler: required")
	}
	type Plain SpecDistributionModulesAwsClusterAutoScaler
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAwsClusterAutoScaler(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthProvider_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesAuthProvider_1: required")
	}
	type Plain SpecDistributionModulesAuthProvider_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuthProvider_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthProviderType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesAuthProviderType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesAuthProviderType, v)
	}
	*j = SpecDistributionModulesAuthProviderType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthProviderBasicAuth_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["password"]; !ok || v == nil {
		return fmt.Errorf("field password in SpecDistributionModulesAuthProviderBasicAuth_1: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username in SpecDistributionModulesAuthProviderBasicAuth_1: required")
	}
	type Plain SpecDistributionModulesAuthProviderBasicAuth_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuthProviderBasicAuth_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthPomerium_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["secrets"]; !ok || v == nil {
		return fmt.Errorf("field secrets in SpecDistributionModulesAuthPomerium_1: required")
	}
	type Plain SpecDistributionModulesAuthPomerium_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuthPomerium_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthPomeriumSecrets_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["COOKIE_SECRET"]; !ok || v == nil {
		return fmt.Errorf("field COOKIE_SECRET in SpecDistributionModulesAuthPomeriumSecrets_1: required")
	}
	if v, ok := raw["IDP_CLIENT_SECRET"]; !ok || v == nil {
		return fmt.Errorf("field IDP_CLIENT_SECRET in SpecDistributionModulesAuthPomeriumSecrets_1: required")
	}
	if v, ok := raw["SHARED_SECRET"]; !ok || v == nil {
		return fmt.Errorf("field SHARED_SECRET in SpecDistributionModulesAuthPomeriumSecrets_1: required")
	}
	type Plain SpecDistributionModulesAuthPomeriumSecrets_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuthPomeriumSecrets_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthOverridesIngresses_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["host"]; !ok || v == nil {
		return fmt.Errorf("field host in SpecDistributionModulesAuthOverridesIngresses_1: required")
	}
	if v, ok := raw["ingressClass"]; !ok || v == nil {
		return fmt.Errorf("field ingressClass in SpecDistributionModulesAuthOverridesIngresses_1: required")
	}
	type Plain SpecDistributionModulesAuthOverridesIngresses_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuthOverridesIngresses_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionCommon_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nodeSelector"]; !ok || v == nil {
		return fmt.Errorf("field nodeSelector in SpecDistributionCommon_1: required")
	}
	if v, ok := raw["provider"]; !ok || v == nil {
		return fmt.Errorf("field provider in SpecDistributionCommon_1: required")
	}
	if v, ok := raw["relativeVendorPath"]; !ok || v == nil {
		return fmt.Errorf("field relativeVendorPath in SpecDistributionCommon_1: required")
	}
	if v, ok := raw["tolerations"]; !ok || v == nil {
		return fmt.Errorf("field tolerations in SpecDistributionCommon_1: required")
	}
	type Plain SpecDistributionCommon_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionCommon_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesKubeToleration) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["effect"]; !ok || v == nil {
		return fmt.Errorf("field effect in TypesKubeToleration: required")
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key in TypesKubeToleration: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in TypesKubeToleration: required")
	}
	type Plain TypesKubeToleration
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TypesKubeToleration(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesKubeTolerationEffect) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesKubeTolerationEffect {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesKubeTolerationEffect, v)
	}
	*j = TypesKubeTolerationEffect(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EksclusterKfdV1Alpha2JsonKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EksclusterKfdV1Alpha2JsonKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EksclusterKfdV1Alpha2JsonKind, v)
	}
	*j = EksclusterKfdV1Alpha2JsonKind(v)
	return nil
}

var enumValues_TypesKubeTolerationEffect = []interface{}{
	"NoSchedule",
	"PreferNoSchedule",
	"NoExecute",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Metadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Metadata: required")
	}
	type Plain Metadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Metadata(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EksclusterKfdV1Alpha2Json) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["apiVersion"]; !ok || v == nil {
		return fmt.Errorf("field apiVersion in EksclusterKfdV1Alpha2Json: required")
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind in EksclusterKfdV1Alpha2Json: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata in EksclusterKfdV1Alpha2Json: required")
	}
	if v, ok := raw["spec"]; !ok || v == nil {
		return fmt.Errorf("field spec in EksclusterKfdV1Alpha2Json: required")
	}
	type Plain EksclusterKfdV1Alpha2Json
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EksclusterKfdV1Alpha2Json(plain)
	return nil
}
